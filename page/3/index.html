<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Kirang Haerang:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="神秘的世界">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="神秘的世界">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>神秘的世界</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">神秘的世界</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0One/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0One/" class="post-title-link" itemprop="url">Java多线程的学习笔记--线程的基础特性、线程的创建、网图抓取相关包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-26 21:54:29" itemprop="dateCreated datePublished" datetime="2021-11-26T21:54:29+08:00">2021-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-03 22:16:42" itemprop="dateModified" datetime="2021-12-03T22:16:42+08:00">2021-12-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="屁话"><a href="#屁话" class="headerlink" title="屁话"></a>屁话</h2><p>​        这篇文章来记录在学习 Java多线程 的相关基础时的一部分想法。这次主要包含 <strong>线程的基础特性</strong>， <strong>线程的创建</strong> 和 <strong>网图抓取相关的包和操作</strong> 三个部分的内容。</p>
<h2 id="线程的基础特性"><a href="#线程的基础特性" class="headerlink" title="线程的基础特性"></a>线程的基础特性</h2><p>​        解释线程之前需要稍微提一下线程运行的前提，进程 和 程序。</p>
<h4 id="进程-和-程序"><a href="#进程-和-程序" class="headerlink" title="进程 和 程序"></a>进程 和 程序</h4><p>​        程序是静态的，需要在操作系统中运行时，程序才可以发挥作用。而进程，就是在操作系统中运行的程序。</p>
<p>​        进程是系统资源分配的单位，在一个进程中可以有多个线程( 比如主线程main、守护线程gc )。</p>
<p>​    </p>
<h4 id="线程的一些基本属性"><a href="#线程的一些基本属性" class="headerlink" title="线程的一些基本属性"></a>线程的一些基本属性</h4><p>​        在上方解释了进程的概念，而线程就是独立的执行路径。在一个进程中，如果开辟有多个线程，那么线程的运行全部由调度器( 也就是CPU ) 统一安排，先后顺序无法人为干预。</p>
<p>​        对于单线程而言，如果在调用主线程main时，调用某一个函数，那么系统会先暂停main的执行。在执行完调用的目标函数后，继续执行main。</p>
<p>​        对于多线程而言，如果在调用主线程main时，调用某一个函数，那么理论上系统会同时执行main函数和目标的调用函数。不过要注意的是，对于大多计算机而言，多线程的程序都属于模拟多线程。因为执行线程需要CPU，而CPU只有一个，只能一次性执行一个线程，不过CPU的执行速度十分之快，几乎可以实现多线程的效果。</p>
<p>​        另外，十分重要的是，在对同一份资源进行操作时，极大概率会出现资源抢夺，需要加入并发控制。同时，线程的增多会带来额外的CPU开销。</p>
<p>​        在线程开启后，开启的线程不一定立刻执行，具体顺序由CPU进行调度。</p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>​        线程的创建有三种常用的方式：</p>
<ul>
<li>继承 Thread 类</li>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口</li>
</ul>
<h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><p>​        操作流程：继承 Thread 类 &gt;&gt; 重写 run 方法，在 run 方法中编写线程执行体 &gt;&gt; 创建线程对象，调用 start 方法启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadOne</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基础 Thread 类，重写 run 方法，使用 start 方法启动线程</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;Test Run&quot;</span> + i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadOne testThreadOne = <span class="keyword">new</span> TestThreadOne();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处会启动线程</span></span><br><span class="line">        testThreadOne.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;Test Main&quot;</span> + i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><p>​        操作流程：实现 Runnable 接口 &gt;&gt; 重写 run 方法，在方法内部编写线程主体 &gt;&gt; 创建线程对象，调用 start 方法启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunnableOne</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程方式2 实现 Runnable 接口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;Test Run : &quot;</span> + i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestRunnableOne testRunnableOne = <span class="keyword">new</span> TestRunnableOne();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread( testRunnableOne ).start();</span><br><span class="line">        <span class="comment">// 此处的代码等价于</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Thread thread = new Thread( testRunnableOne );</span></span><br><span class="line"><span class="comment">            thread.start();</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;Test Main : &quot;</span> + i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        此处要注意的是，使用实现 Runnable 接口的方法来创建线程的话，在启动线程时，不能直接调用 start 方法。需要创建一个 Thread 类对象，将实现了 Runnable 接口的类对象作为参数传入 Thread 的构造方法中。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread( testRunnableOne ).start();</span><br><span class="line">      <span class="comment">// 此处的代码等价于</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Thread thread = new Thread( testRunnableOne );</span></span><br><span class="line"><span class="comment">          thread.start();</span></span><br><span class="line"><span class="comment">      * */</span></span><br></pre></td></tr></table></figure>

<p>​        另外，虽然代码中没有体现。但是在创建线程时是可以为线程起名的，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread( testRunnableOne, <span class="string">&quot;test&quot;</span> ).start();</span><br></pre></td></tr></table></figure>

<p>​        再提一嘴，虽然三种方式都可以创建线程，但是平时推荐使用第二种和第三种。第三种通过实现 Callable 接口是市面上许多公司的用法，而第二种通过实现 Runnable 接口可以使得同一个对象被多个线程使用，避开了 Java 单继承的局限性。</p>
<h4 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h4><p>​        操作流程：实现 Callable 接口，需要返回值 &gt;&gt; 重写 Call 方法，需要抛出异常 &gt;&gt; 创建目标对象 &gt;&gt; 创建执行服务 &gt;&gt; 提交执行 &gt;&gt; 获取结果 &gt;&gt; 关闭服务</p>
<p>​        十分明显的，通过实现 Callable 接口的方式比起另外两种方式要繁琐不少，尤其是后四步，是另外两种方式所不具有的。那么简单给出后四步代码操作的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建执行服务	ExecutorService service = Executors.newFixedThreadPool( 3 );</span></span><br><span class="line"><span class="comment">// 在这里的参数填写需要创建多少条线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交执行	Future&lt; Boolean &gt; future_1 = service.submit( callableOne );</span></span><br><span class="line"><span class="comment">// callableOne 是一个实现了 Callable 接口的实例对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果 boolean r1 = future_1.get();</span></span><br><span class="line"><span class="comment">// 通过 get 函数获取结果，返回值不一定是 boolean，与最开始实现 Callable 接口所定义的返回值相关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭服务	service.shutdownNow();</span></span><br><span class="line"><span class="comment">// 通过 shutdownNow 方法关闭服务，代码结束</span></span><br></pre></td></tr></table></figure>

<p>​        在对这个方法多出来的步骤进行解释后，下面给出一个使用 Callable 接口实现多线程下载指定网图的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 使用实现 Callable 接口来进行创建线程</span></span><br><span class="line">    <span class="keyword">private</span> String fileUrl; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String fileName; <span class="comment">// 保存用的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">( String fileUrl, String fileName )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        <span class="keyword">this</span>.fileUrl = fileUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WebDownloaderPlus webDownloaderPlus = <span class="keyword">new</span> WebDownloaderPlus();</span><br><span class="line"></span><br><span class="line">        webDownloaderPlus.downLoader( fileUrl, fileName );</span><br><span class="line">        System.out.println( <span class="string">&quot;下载的文件名为：&quot;</span> + fileName );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable callableOne = <span class="keyword">new</span> TestCallable( <span class="string">&quot;https://i1.hdslb.com/bfs/archive/030e00ec6c7b8e0263a0fc1ae00c0f433dba6e90.png&quot;</span>, <span class="string">&quot;Ailisa.png&quot;</span> );</span><br><span class="line">        TestCallable callableTwo = <span class="keyword">new</span> TestCallable( <span class="string">&quot;https://i1.hdslb.com/bfs/archive/e59aac45da468e85dcbd0312e720aecb22851bba.png&quot;</span>, <span class="string">&quot;Anna.png&quot;</span> );</span><br><span class="line">        TestCallable callableThree = <span class="keyword">new</span> TestCallable( <span class="string">&quot;https://i0.hdslb.com/bfs/archive/4bb86278ce6d1ffde15f3a2efc40e51007137fe8.jpg&quot;</span>, <span class="string">&quot;Grapefruit.jpg&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool( <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt; Boolean &gt; future_1 = service.submit( callableOne );</span><br><span class="line">        Future&lt; Boolean &gt; future_2 = service.submit( callableTwo );</span><br><span class="line">        Future&lt; Boolean &gt; future_3 = service.submit( callableThree );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        <span class="keyword">boolean</span> r1 = future_1.get();</span><br><span class="line">        <span class="keyword">boolean</span> r2 = future_2.get();</span><br><span class="line">        <span class="keyword">boolean</span> r3 = future_3.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        service.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloaderPlus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downLoader</span><span class="params">( String fileURL, String fileName )</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile( <span class="keyword">new</span> URL( fileURL ), <span class="keyword">new</span> File( fileName ) );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println( <span class="string">&quot;IO异常，downLoader方法出现错误&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        在上方的代码执行后，目标URL所指向的图片会被下载到代码所在的工程目录下。</p>
<h2 id="网图抓取相关的包-和-操作"><a href="#网图抓取相关的包-和-操作" class="headerlink" title="网图抓取相关的包 和 操作"></a>网图抓取相关的包 和 操作</h2><p>​        在用 Java 程序抓取网图前，需要一定的前置操作，因为 Java 本身的库并没有自带有关的库。</p>
<h4 id="commons-IO包"><a href="#commons-IO包" class="headerlink" title="commons-IO包"></a>commons-IO包</h4><p>​        这是一个外置的 Jar 包，其中提供了关于网图的有关操作，可以通过百度直接在官网下载。</p>
<p>​        在导入 Jar 包后，并不能直接使用，如果IDE使用的是 IDEA 。那么可以通过右键 ”连接到库“ 的方式来将 Jar 包加入库中。如果 Jar 包出现可以打开的箭头，说明导入成功了。</p>
<p>​    </p>
<h4 id="网图指定抓取的操作"><a href="#网图指定抓取的操作" class="headerlink" title="网图指定抓取的操作"></a>网图指定抓取的操作</h4><p>​        由于是精确的抓取某张图片，因此需要某张图片精确的URL。可以通过在浏览器中按 F12 打开管理器，在选中图片后会有复制其中的URL。其特点就是 以 http 或 https 开头，以 png 或 jpg 等文件后缀结束。</p>
<p>​        那么下面给出两种代码，一种通过实现 Callable 接口来进行抓取，一种通过继承 Thread 类进行抓取。</p>
<p>​        实现 Callable 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 使用实现 Callable 接口来进行创建线程</span></span><br><span class="line">    <span class="keyword">private</span> String fileUrl; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String fileName; <span class="comment">// 保存用的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">( String fileUrl, String fileName )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        <span class="keyword">this</span>.fileUrl = fileUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WebDownloaderPlus webDownloaderPlus = <span class="keyword">new</span> WebDownloaderPlus();</span><br><span class="line"></span><br><span class="line">        webDownloaderPlus.downLoader( fileUrl, fileName );</span><br><span class="line">        System.out.println( <span class="string">&quot;下载的文件名为：&quot;</span> + fileName );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable callableOne = <span class="keyword">new</span> TestCallable( <span class="string">&quot;https://i1.hdslb.com/bfs/archive/030e00ec6c7b8e0263a0fc1ae00c0f433dba6e90.png&quot;</span>, <span class="string">&quot;Ailisa.png&quot;</span> );</span><br><span class="line">        TestCallable callableTwo = <span class="keyword">new</span> TestCallable( <span class="string">&quot;https://i1.hdslb.com/bfs/archive/e59aac45da468e85dcbd0312e720aecb22851bba.png&quot;</span>, <span class="string">&quot;Anna.png&quot;</span> );</span><br><span class="line">        TestCallable callableThree = <span class="keyword">new</span> TestCallable( <span class="string">&quot;https://i0.hdslb.com/bfs/archive/4bb86278ce6d1ffde15f3a2efc40e51007137fe8.jpg&quot;</span>, <span class="string">&quot;Grapefruit.jpg&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool( <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt; Boolean &gt; future_1 = service.submit( callableOne );</span><br><span class="line">        Future&lt; Boolean &gt; future_2 = service.submit( callableTwo );</span><br><span class="line">        Future&lt; Boolean &gt; future_3 = service.submit( callableThree );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        <span class="keyword">boolean</span> r1 = future_1.get();</span><br><span class="line">        <span class="keyword">boolean</span> r2 = future_2.get();</span><br><span class="line">        <span class="keyword">boolean</span> r3 = future_3.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        service.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloaderPlus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downLoader</span><span class="params">( String fileURL, String fileName )</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile( <span class="keyword">new</span> URL( fileURL ), <span class="keyword">new</span> File( fileName ) );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println( <span class="string">&quot;IO异常，downLoader方法出现错误&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>​        通过继承 Thread 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadTwo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 练习 Thread， 实现多线程同步下载网图</span></span><br><span class="line">    <span class="keyword">private</span> String fileUrl; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String fileName; <span class="comment">// 保存用的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThreadTwo</span><span class="params">(String fileUrl, String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        <span class="keyword">this</span>.fileUrl = fileUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载图片的线程执行体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownloader webDownloader = <span class="keyword">new</span> WebDownloader();</span><br><span class="line"></span><br><span class="line">        webDownloader.downLoader( fileUrl, fileName );</span><br><span class="line">        System.out.println( <span class="string">&quot;下载的文件名为：&quot;</span> + fileName );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadTwo testThread_1 = <span class="keyword">new</span> TestThreadTwo( <span class="string">&quot;https://i1.hdslb.com/bfs/archive/030e00ec6c7b8e0263a0fc1ae00c0f433dba6e90.png&quot;</span>, <span class="string">&quot;Ailisa.png&quot;</span> );</span><br><span class="line">        TestThreadTwo testThread_2 = <span class="keyword">new</span> TestThreadTwo( <span class="string">&quot;https://i1.hdslb.com/bfs/archive/e59aac45da468e85dcbd0312e720aecb22851bba.png&quot;</span>, <span class="string">&quot;Anna.png&quot;</span> );</span><br><span class="line">        TestThreadTwo testThread_3 = <span class="keyword">new</span> TestThreadTwo( <span class="string">&quot;https://i0.hdslb.com/bfs/archive/4bb86278ce6d1ffde15f3a2efc40e51007137fe8.jpg&quot;</span>, <span class="string">&quot;Grapefruit.jpg&quot;</span> );</span><br><span class="line"></span><br><span class="line">        testThread_1.start();</span><br><span class="line">        testThread_2.start();</span><br><span class="line">        testThread_3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownloader</span></span>&#123;</span><br><span class="line">    <span class="comment">// 下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downLoader</span><span class="params">( String fileUrl, String fileName )</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile( <span class="keyword">new</span> URL( fileUrl ), <span class="keyword">new</span> Fle( fileName ));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println( <span class="string">&quot;IO异常，downLoader方法出现错误&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/23/Java%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/23/Java%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">Java中文件的输入与输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-23 19:29:44" itemprop="dateCreated datePublished" datetime="2021-11-23T19:29:44+08:00">2021-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-28 15:11:58" itemprop="dateModified" datetime="2022-02-28T15:11:58+08:00">2022-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="屁话"><a href="#屁话" class="headerlink" title="屁话"></a>屁话</h2><p>​        在这篇文章中，讨论一部分Java的文件输入输出机制，当然这只是最基础的一部分。等到日后有时间，可能会专门探讨一下Java的IO体系和国际化的内容。</p>
<h2 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h2><h4 id="流的概念以及分类"><a href="#流的概念以及分类" class="headerlink" title="流的概念以及分类"></a>流的概念以及分类</h4><p>​        Java将所有传统的流模型( 类 或 抽象类 )，都放在了 Java.io 包中，用来实现输入输出的功能。</p>
<p>​        在这里，将流分为两种类型：输入流 和 输出流。</p>
<p>​        输入流：只能从中读取数据，而不能向其中写入数据。其中的代表类：InputStream ( 字节输入流 )，Reader ( 字符输入流 )。</p>
<p>​        输出流：只能向其中写入数据，而不能从中读取数据。其中的代表类：OutputStream ( 字节输出流 )，Writer ( 字节输出流 )。</p>
<p>​        在上文中可以发现，输入流和输出流的相关类中都存在 字符输入/输出 和 字节输入/输出。这其实是流按照操作类型所进行的分类。</p>
<p>​        字节流：字节流可以操作任何数据，因为在计算机中任何数据都是以字节的形式储存的。她操作的数单元式8位的字节。</p>
<p>​        字符流：字符流只能才中纯字符数据，比较方便。她操作的数据单元是16位的字符。</p>
<p>​        </p>
<p>​        那么在这个地方，我们需要分清楚什么是输入，什么是输出。如下图所示：</p>
<p><img src="/2021/11/23/Java%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/1419534-20191109103620179-378109862.png" alt="输入流和输出流"></p>
<p>​        </p>
<p>​        从Java程序指向文件，这个过程我们称之为输出或者写入文件，从文件指向Java程序，这个过程我们称之为输入或者读出文件。</p>
<p>​        在输入流和输出流中，我们主要掌握4个流文件的操作：InputStream, OutputStream, Reader, Writer。这四个类都是抽象类，前两个代表了字节的输入输出流，后两个代表字符的输入输出流，当我们调用的时候通常会使用她们的子类来实现我们的类方法。</p>
<h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h4><p>​        字节输出流 OutputStream 她有    以下几个方法可以提供给她的子类使用。另外要注意的是，在输入输出流中，子类几乎没有什么方法，都是调用父类的方法。</p>
<ul>
<li>void close(  ) : 关闭此输出流并释放与此有关的所有系统资源。</li>
<li>void writer( byte[] b ) : 将b.length 个字节从指定的byte写入此输出流</li>
<li>void writer( byte[] b, int off, int len ) : 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。</li>
<li>abstract void write( int b ) : 将指定的字节写入此输出流。</li>
</ul>
<p>​        由于 OutputStream  是抽象类，因此我们在向文件写入字节的时候，需要用到她的子类 FileOutputStream ,接下来通过使用上面的方法来实现字节流的输出操作。</p>
<h5 id="关于-FileOutputStream"><a href="#关于-FileOutputStream" class="headerlink" title="关于 FileOutputStream"></a>关于 FileOutputStream</h5><pre><code>     1、写入数据文件，通过父类的方法，调用子类的对象。
</code></pre>
<p>​         2、FileOutputStream构造方法：</p>
<p>​              作用：绑定输出的输出目的。</p>
<ul>
<li><p>FileOutputStream(File file)</p>
<ul>
<li>创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</li>
</ul>
</li>
<li><p>FileOutputStream(File file, boolean append)</p>
<ul>
<li>创建一个向指定 File 对象表示的文件中写入数据的文件输出流，以追加的方式写入。</li>
</ul>
</li>
<li><p>FileOutputStream(String name)</p>
<ul>
<li>创建一个向具有指定名称的文件中写入数据的输出文件流。</li>
</ul>
</li>
<li><p>FileOutputStream(String name, boolean append)</p>
<ul>
<li>创建一个向具有指定 name 的文件中写入数据的输出文件流，以追加的方式写入。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream testOne = <span class="keyword">new</span> FileOutputStream( <span class="keyword">new</span> File( <span class="string">&quot;D:/JavaTest/JavaTest.txt&quot;</span> ) );</span><br><span class="line">FileOutputStream testTwo = <span class="keyword">new</span> FileOutputStream( <span class="keyword">new</span> File( <span class="string">&quot;D:/JavaTest/JavaTest.txt&quot;</span> ), <span class="keyword">true</span> );</span><br><span class="line">FileOutputStream testThree = <span class="keyword">new</span> FileOutputStream( <span class="string">&quot;JavaTest&quot;</span>  );</span><br><span class="line">FileOutputStream testFour = <span class="keyword">new</span> FileOutputStream( <span class="string">&quot;JavaTest&quot;</span>, <span class="keyword">true</span> );</span><br></pre></td></tr></table></figure>

<p>​        </p>
<h5 id="流对象的使用步骤-和-注意事项"><a href="#流对象的使用步骤-和-注意事项" class="headerlink" title="流对象的使用步骤 和 注意事项"></a>流对象的使用步骤 和 注意事项</h5><h6 id="流对象的使用步骤"><a href="#流对象的使用步骤" class="headerlink" title="流对象的使用步骤"></a>流对象的使用步骤</h6><p>​        1、创建流子类的对象，绑定数据目的。</p>
<p>​        2、调用流对象的方法write写入数据</p>
<p>​        3、close释放资源</p>
<p>​        </p>
<h6 id="使用时的注意事项"><a href="#使用时的注意事项" class="headerlink" title="使用时的注意事项"></a>使用时的注意事项</h6><p>​        流对象的构造方法，可以用来创建文件，如果文件存在的情况下，直接会覆盖原本的文件。</p>
<h5 id="字节输出流的代码实现"><a href="#字节输出流的代码实现" class="headerlink" title="字节输出流的代码实现"></a>字节输出流的代码实现</h5><h6 id="输出单个字节"><a href="#输出单个字节" class="headerlink" title="输出单个字节"></a>输出单个字节</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Notes.Java文件操作;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File( <span class="string">&quot;C:/Users/Arsh/Desktop/JavaTest/JavaTest.txt&quot;</span> );</span><br><span class="line">        FileOutputStream testOne = <span class="keyword">new</span> FileOutputStream( file );</span><br><span class="line">        </span><br><span class="line">        testOne.write( <span class="number">97</span> );</span><br><span class="line">        testOne.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        最终结果：</p>
<p><img src="/2021/11/23/Java%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/OutputOne.png" alt="Output"></p>
<h6 id="输出字节数组"><a href="#输出字节数组" class="headerlink" title="输出字节数组"></a>输出字节数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Notes.Java文件操作;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File( <span class="string">&quot;C:/Users/Arsh/Desktop/JavaTest/JavaTest.txt&quot;</span> );</span><br><span class="line">        FileOutputStream testOne = <span class="keyword">new</span> FileOutputStream( file );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = &#123; <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span> &#125;;</span><br><span class="line"></span><br><span class="line">        testOne.write( bytes );</span><br><span class="line">        testOne.write( bytes, <span class="number">1</span>, <span class="number">2</span> );</span><br><span class="line">        testOne.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        最终结果：</p>
<p><img src="/2021/11/23/Java%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/OutputTwo.png" alt="Output"></p>
<h4 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h4><p>​        字节输入流她有以下几个方法提供她的子类使用，和字节输入流相同，子类几乎没有方法，都是调用父类的方法。</p>
<ul>
<li><p>abstract int read(  ) : 从输入流中读取数据的下一个字节，返回-1表示文件结束</p>
</li>
<li><p>int read( byte[] b ) : 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 -1。</p>
</li>
<li><p>int read( byte[] b, int off, int len ) :  将输入流中最多 len 个数据字节读入 byte 数组。</p>
</li>
<li><p>void close(  ) : 关闭此输入流并释放与该流相关的所有系统资源。</p>
</li>
</ul>
<p>​        由于InputStream是抽象类，因此我们在从文件读取(输入)字节的时候，需要用到它的子类 FileInputStream ,接下来通过使用上面的方法，来实现字节流的输入操作。</p>
<h5 id="关于-FileInputStream"><a href="#关于-FileInputStream" class="headerlink" title="关于 FileInputStream"></a>关于 FileInputStream</h5><p>​        在使用FileInputStream创建对象的时候，我们也需要为这个类绑定数据源(我们要读取的文件名)</p>
<p>FileInputStream的构造方法与上述的构造方法相似，里面的参数有两种类型：File类型对象, String类型对象。</p>
<p>​        她们的构造函数基本相同，包括参数的数量和类型 。</p>
<h5 id="流对象的使用步骤-和-注意事项-1"><a href="#流对象的使用步骤-和-注意事项-1" class="headerlink" title="流对象的使用步骤 和 注意事项"></a>流对象的使用步骤 和 注意事项</h5><h6 id="输入流读取文件的操作步骤"><a href="#输入流读取文件的操作步骤" class="headerlink" title="输入流读取文件的操作步骤"></a>输入流读取文件的操作步骤</h6><p>​        1、创建字节输入流的子类对象</p>
<p>​        2、调用读取方法read进行读取</p>
<p>​        3、关闭资源</p>
<p>​        </p>
<h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><p>​        read(  ) 方法每次执行一次，就会自动读取下一个字节。她的返回值是读取到的字节，如果没有字节可以读取，那么返回 -1.</p>
<h5 id="字符输入流的代码实现"><a href="#字符输入流的代码实现" class="headerlink" title="字符输入流的代码实现"></a>字符输入流的代码实现</h5><h6 id="按照每个字符逐个读取文件中的内容-效率较低"><a href="#按照每个字符逐个读取文件中的内容-效率较低" class="headerlink" title="按照每个字符逐个读取文件中的内容( 效率较低 )"></a>按照每个字符逐个读取文件中的内容( 效率较低 )</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Notes.Java文件操作;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream testOne = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:/Users/Arsh/Desktop/JavaTest/JavaTest.txt&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Read = <span class="number">0</span>; <span class="comment">// 当Read的值变为 -1 时，说明文件已经读取完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( ( Read = testOne.read() ) != -<span class="number">1</span> )&#123;</span><br><span class="line">            System.out.print( (<span class="keyword">char</span>) Read );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        testOne.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​                最终结果：</p>
<p><img src="/2021/11/23/Java%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/InputOne.png"></p>
<h6 id="读取字节数组"><a href="#读取字节数组" class="headerlink" title="读取字节数组"></a>读取字节数组</h6><p>​        这个方法是基于一些原理才成立的：</p>
<p>​        1）int read( byte[] b ) : 从输入流中读取一定数量的字节，并将其储存在缓冲数组 b 中。读入缓冲区的字节总数，如果因为已经到达文件末尾而没有更多的数据，则返回 -1。</p>
<p>​        2）int read( byte[] b, int off, int len ) : 将输入流中最多 len 个数据字节读入 byte 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Notes.Java文件操作;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream testOne = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:/Users/Arsh/Desktop/JavaTest/JavaTest.txt&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[ <span class="number">1024</span> ];</span><br><span class="line">        <span class="keyword">int</span> Read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( ( Read = testOne.read(bytes) ) != -<span class="number">1</span> )&#123;</span><br><span class="line">            System.out.print( <span class="keyword">new</span> String( bytes, <span class="number">0</span>, Read ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        testOne.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        最终结果：</p>
<p><img src="/2021/11/23/Java%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/InputOne.png"></p>
<p>​        虽然两种方法的最终结果相同，但第二种方法的效率和所耗时间对比于第一种方法更少。</p>
<p>​    </p>
<h4 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h4><p>​        由于Writer也是一个抽象类，因此我们用它的子类 FileWriter 来实现字符流的输出操作。</p>
<h5 id="关于FileWriter"><a href="#关于FileWriter" class="headerlink" title="关于FileWriter"></a>关于FileWriter</h5><ul>
<li>void write(int c) : 写入单个字符。</li>
<li>void write(String str) : 写入字符串。</li>
<li>void write(String str, int off, int len) : 写入字符串的某一部分。</li>
<li>void write(char[] cbuf) : 写入字符数组。</li>
<li>abstract void write(char[] cbuf, int off, int len) : 写入字符数组的某一部分。</li>
</ul>
<p>　　</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Notes.Java文件操作;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter testOne = <span class="keyword">new</span> FileWriter( <span class="string">&quot;C:/Users/Arsh/Desktop/JavaTest/JavaTest.txt&quot;</span> );</span><br><span class="line"></span><br><span class="line">        testOne.write(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        testOne.flush();</span><br><span class="line">        testOne.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        显示结果：<img src="/2021/11/23/Java%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/FileWrite.png"></p>
<h4 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h4><h5 id="关于FileReader"><a href="#关于FileReader" class="headerlink" title="关于FileReader"></a>关于FileReader</h5><p>​        由于Reader也是一个抽象类，因此我们用它的子类FileReader来实现字符流的输出操作。</p>
<ul>
<li>int read(  ) : 读取单个字符</li>
<li>int read( char[] cbuf ) : 将字符读入数组</li>
<li>abstract int read( char[] cbuf, int off, int len ) : 将字符读入数组的某一部分。</li>
</ul>
<p>　　</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Notes.Java文件操作;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader testOne = <span class="keyword">new</span> FileReader( <span class="string">&quot;C:/Users/Arsh/Desktop/JavaTest/JavaTest.txt&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( ( Read = testOne.read() ) != -<span class="number">1</span> )</span><br><span class="line">            System.out.print( (<span class="keyword">char</span>) Read );</span><br><span class="line"></span><br><span class="line">        testOne.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        结果显示：</p>
<p><img src="/2021/11/23/Java%E4%B8%AD%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/FileReader.png"></p>
<p>​        </p>
<h4 id="字符流和字节流的区别"><a href="#字符流和字节流的区别" class="headerlink" title="字符流和字节流的区别"></a>字符流和字节流的区别</h4><p>​        对于Java，字符流的输入输出与字节流的差不多，但是字符流只能操作文本文件，不能操作除了文本文件以外的文件，而字节流可以操作文本文件以及音乐，视频等文件，因此在平时的IO流中，我们使用字节流的操作更多一些。</p>
<h2 id="对某一文件进行读写的代码实现"><a href="#对某一文件进行读写的代码实现" class="headerlink" title="对某一文件进行读写的代码实现"></a>对某一文件进行读写的代码实现</h2><h5 id="针对某个文件的写入"><a href="#针对某个文件的写入" class="headerlink" title="针对某个文件的写入"></a>针对某个文件的写入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Notes.Java文件操作;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">new</span> FileWriter();</span><br><span class="line">        fileWriter.FileWriterTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FileWriterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//JDK7以前的版本操作方法</span></span><br><span class="line">        FileOutputStream FW = <span class="keyword">null</span>;</span><br><span class="line">        OutputStreamWriter OW = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter BW = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FW = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:/Users/Arsh/Desktop/JavaTest/JavaTest.txt&quot;</span>);</span><br><span class="line">            OW = <span class="keyword">new</span> OutputStreamWriter(FW, StandardCharsets.UTF_8);</span><br><span class="line">            BW = <span class="keyword">new</span> BufferedWriter(OW);</span><br><span class="line"></span><br><span class="line">            BW.write(<span class="string">&quot;JavaFileTest&quot;</span>);</span><br><span class="line">            BW.newLine();</span><br><span class="line">            BW.write(<span class="string">&quot;The Java fest&quot;</span>);</span><br><span class="line">            BW.newLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (BW != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    BW.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        从上文可以看出，为了保证安全，需要 3 个比较重要的类，即 FileOutputStream，OutputStreamWriter，Buffered Writer 。三个类相互层叠，最终完成可以直接写入字符串的操作。如果不是用装饰类，则只能做到将字符数组写入文件，而这十分麻烦。</p>
<h5 id="针对某个文件的读取"><a href="#针对某个文件的读取" class="headerlink" title="针对某个文件的读取"></a>针对某个文件的读取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Notes.Java文件操作;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">new</span> FileWriter();</span><br><span class="line">        fileWriter.FileReaderTest( <span class="string">&quot;C:/Users/Arsh/Desktop/JavaTest/JavaTest.txt&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FileReaderTest</span><span class="params">(String Path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> FileInputStream( Path );</span><br><span class="line">            inputStreamReader = <span class="keyword">new</span> InputStreamReader( fileInputStream, StandardCharsets.UTF_8 );</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader( inputStreamReader );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] chars = <span class="keyword">new</span> <span class="keyword">byte</span>[ <span class="number">1024</span> ];</span><br><span class="line">            <span class="keyword">int</span> Read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ( ( Read = bufferedReader.read(chars) ) != -<span class="number">1</span> )&#123;</span><br><span class="line">                System.out.print( <span class="keyword">new</span> String( chars, <span class="number">0</span>, Read ) );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​        在上文中，有几个地方需要特别说明的。</p>
<p>​        首先，读取代码和写入代码相似，都需要相关的类：FileInputStream， InputStreamReader， Buffered Reader 。后两个类属于装饰类，可以帮助系统更好的进行对文件的读写。</p>
<p>​        其次，需要对以下代码进行解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="number">1024</span> ];</span><br><span class="line"><span class="keyword">int</span> Read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( ( Read = bufferedReader.read(chars) ) != -<span class="number">1</span> )&#123;</span><br><span class="line">	System.out.print( <span class="keyword">new</span> String( chars, <span class="number">0</span>, Read ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这种读取方式的核心思想是通过一个char型数组来一次性接收目标文件中的所有代码，而 Read 的作用是确认char型数组的长度，也就是文件中内容的长度。然后再打印部分，通过 new 一个字符串，提取出 char 型数组中从 0 到 Read 的字符( 也就是文件中的内容 )，并组成一个字符串。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/10/Java%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/10/Java%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">Java学习中出现过的异常</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-10 14:17:00" itemprop="dateCreated datePublished" datetime="2021-11-10T14:17:00+08:00">2021-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-08 23:20:22" itemprop="dateModified" datetime="2022-07-08T23:20:22+08:00">2022-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="屁话"><a href="#屁话" class="headerlink" title="屁话"></a>屁话</h2><p>​        这篇 Blog 来记录我们在学习中碰到的一些奇奇怪怪的异常。</p>
<h4 id="java-lang-StackOverflowError"><a href="#java-lang-StackOverflowError" class="headerlink" title="java.lang.StackOverflowError"></a>java.lang.StackOverflowError</h4><p>​        异常：栈溢出</p>
<p>​        可能原因：由于递归函数的书写错误 或者 由于使用递归函数时传入的参数错误 导致的无限循环，最终导致了堆栈的溢出。但相对的，如果是陷入了死循环，那么一般不会抛出错误。</p>
<h4 id="java-lang-ArithmeticException-by-zero"><a href="#java-lang-ArithmeticException-by-zero" class="headerlink" title="java.lang.ArithmeticException: / by zero"></a>java.lang.ArithmeticException: / by zero</h4><p>​        异常：算数异常 / 归零</p>
<p>​        可能原因：在官方文档中对此做出了说明，当出现异常的运算条件时，抛出此异常。一般而言，出现此异常时，是由于某个计算式中有 被除数( 分母 ) 为0的情况。</p>
<h4 id="java-lang-ArrayIndexOutOfBoundsException"><a href="#java-lang-ArrayIndexOutOfBoundsException" class="headerlink" title="java.lang.ArrayIndexOutOfBoundsException"></a>java.lang.ArrayIndexOutOfBoundsException</h4><p>​        异常：数组下标越界异常；数组索引越界异常；数组越界</p>
<p>​        可能原因：在调用某个数组时，出现了索引越界。</p>
<h4 id="java-lang-OutOfMemoryError-Java-heap-space"><a href="#java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="java.lang.OutOfMemoryError: Java heap space"></a>java.lang.OutOfMemoryError: Java heap space</h4><p>​        异常：内存溢出错误</p>
<p>​        可能原因：发生这种问题的原因是java虚拟机创建的对象太多，在进行垃圾回收之间，虚拟机分配的到堆内存空间已经用满了，与Heap space有关。解决这类问题有两种思路：</p>
<ol>
<li>检查程序，看是否有死循环或不必要地重复创建大量对象。找到原因后，修改程序和算法。</li>
<li>增加Java虚拟机中Xms（初始堆大小）和Xmx（最大堆大小）参数的大小。如：set JAVA_OPTS= -Xms256m -Xmx1024m</li>
</ol>
<h4 id="不支持发行版本-5-不支持发行版本13"><a href="#不支持发行版本-5-不支持发行版本13" class="headerlink" title="不支持发行版本 5 / 不支持发行版本13"></a>不支持发行版本 5 / 不支持发行版本13</h4><p>​        异常：不支持发行版本 5</p>
<p>​        可能原因：JDK 和 运行环境的不匹配导致，可以通过修改 pom.xml 文件来修复这种错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 处理 java 错误：不支持发行版本 5 --&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;13&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;13&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>



<h4 id="Type-interface-XXXXXXXX-is-not-known-to-the-MapperRegistry"><a href="#Type-interface-XXXXXXXX-is-not-known-to-the-MapperRegistry" class="headerlink" title="Type interface XXXXXXXX is not known to the MapperRegistry"></a>Type interface XXXXXXXX is not known to the MapperRegistry</h4><p>​        异常：未确定 / 未识别 的接口类型</p>
<p>​        可能原因：对应的 XML 配置文件未被配置，需要在 mybatis-config.xml 也就是总 MyBatis 的总配置文件中注册对应的 XML</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 进行 Mapper 的注册 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以在一个标签中注册多个 XML 配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/EveArsh/Dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="MyBatis-框架的使用中：-java-lang-ExceptionInInitializerError"><a href="#MyBatis-框架的使用中：-java-lang-ExceptionInInitializerError" class="headerlink" title="MyBatis 框架的使用中： java.lang.ExceptionInInitializerError"></a>MyBatis 框架的使用中： java.lang.ExceptionInInitializerError</h4><p>​        异常：初始化失败</p>
<p>​        可能原因：基于 Maven 约定大于配置的属性，XML 配置文件可能未被成功导出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 解决资源导出问题 --&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**<span class="comment">/*.properties&lt;/include&gt;</span></span><br><span class="line"><span class="comment">                &lt;include&gt;**/</span>*.xml&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;filtering&gt;<span class="keyword">true</span>&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**<span class="comment">/*.properties&lt;/include&gt;</span></span><br><span class="line"><span class="comment">                &lt;include&gt;**/</span>*.xml&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;filtering&gt;<span class="keyword">true</span>&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/08/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/08/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/" class="post-title-link" itemprop="url">学习笔记——算法设计的学习笔记 Two</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-08 23:01:30" itemprop="dateCreated datePublished" datetime="2021-11-08T23:01:30+08:00">2021-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-21 16:59:32" itemprop="dateModified" datetime="2021-11-21T16:59:32+08:00">2021-11-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="屁话"><a href="#屁话" class="headerlink" title="屁话"></a>屁话</h2><p>​        这是算法课上的弄到的题目，一共4个，下面对他们进行解答（给上题目）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* Q1. 背包问题（贪心算法）</span><br><span class="line">    假设一背包承重为<span class="number">10</span>斤，怎样放入水果使得背包中的价值最大，水果信息如下：</span><br><span class="line">    水果		重量		价值</span><br><span class="line">     <span class="number">1</span>		   <span class="number">2</span>        <span class="number">6</span></span><br><span class="line">     <span class="number">2</span>		   <span class="number">2</span>        <span class="number">3</span></span><br><span class="line">     <span class="number">3</span>		   <span class="number">6</span>        <span class="number">5</span></span><br><span class="line">     <span class="number">4</span>		   <span class="number">5</span>        <span class="number">4</span></span><br><span class="line">     <span class="number">5</span>		   <span class="number">4</span>        <span class="number">6</span></span><br><span class="line">    </span><br><span class="line">* Q2. 海盗喝酒问题</span><br><span class="line">    有一群海盗（不多于<span class="number">20</span>人），在船上比拼酒量。过程如下：</span><br><span class="line">    打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。</span><br><span class="line">    再打开一瓶酒平分，又有倒下的，再次重复……</span><br><span class="line">    直到开了第<span class="number">4</span>瓶酒，坐着的已经所剩无几，海盗船长也在其中。</span><br><span class="line">	当第<span class="number">4</span>瓶酒平分喝下后，大家都倒下了。 </span><br><span class="line">    等船长醒来，发现海盗船搁浅了。</span><br><span class="line">	他在航海日志中写到：“……昨天，我正好喝了一瓶…….奉劝大家，开船不喝酒，喝酒别开船……”</span><br><span class="line">	请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。</span><br><span class="line">	如果有多个可能的答案，请列出所有答案，每个答案占一行。</span><br><span class="line">    </span><br><span class="line">* Q3. 给定整数 n 和 m，满足 n 能被 2m 整除。对于一串连续递增整数数列<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span>，每隔 m 个符号反转一次，最初的符号为<span class="string">&#x27;-&#x27;</span></span><br><span class="line">    例如：</span><br><span class="line">    n = <span class="number">8</span>, m = <span class="number">2</span>, 数列就是：-<span class="number">1</span>, -<span class="number">2</span>, +<span class="number">3</span>, +<span class="number">4</span>, -<span class="number">5</span>, -<span class="number">6</span>, +<span class="number">7</span>, +<span class="number">8</span></span><br><span class="line">    n = <span class="number">4</span>, m = <span class="number">1</span>, 数列就是：-<span class="number">1</span>, +<span class="number">2</span>, -<span class="number">3</span>, +<span class="number">4</span></span><br><span class="line">    求前 n 项和。（<span class="number">2</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">9</span> ）（时间限制为 <span class="number">1</span> 秒，空间限制32768k）</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">* Q4. 某市市长获得了若干批口罩，给定没批口罩的数量，每一批口罩的数目如下：</span><br><span class="line">    <span class="number">9090400</span>	<span class="number">8499400</span>	<span class="number">5926800</span>	<span class="number">8547000</span>	<span class="number">4958200</span>	<span class="number">4422600</span>	<span class="number">5751200</span>	<span class="number">4175600</span>	</span><br><span class="line">    <span class="number">6309600</span>	<span class="number">5865200</span>	<span class="number">6604400</span>	<span class="number">4635000</span>	<span class="number">10663400</span> <span class="number">8087200</span> <span class="number">4554000</span></span><br><span class="line">    市长要把口罩分配给室内的 <span class="number">2</span> 所医院，由于物流限制，每一批口罩只能全部分配给其中一家医院。</span><br><span class="line">    市长希望 <span class="number">2</span> 所医院所获得的口罩总数只差越小越好。请你计算这个最小差是多少？</span><br></pre></td></tr></table></figure>



<h2 id="题目-和-题解"><a href="#题目-和-题解" class="headerlink" title="题目 和 题解"></a>题目 和 题解</h2><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>​    背包问题（贪心算法）<br>​    假设一背包承重为10斤，怎样放入水果使得背包中的价值最大，水果信息如下：<br>​    水果        重量         价值<br>​     1               2             6<br>​     2               2             3<br>​     3               6             5<br>​     4               5             4<br>​     5               4             6</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">questionOne</span><span class="params">(<span class="keyword">int</span> packageSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内部类 Fruit 用来表示水果</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> id;</span><br><span class="line">                <span class="keyword">double</span> wight,value;</span><br><span class="line">                <span class="keyword">double</span> gain = <span class="number">0</span>; <span class="comment">// 是否获取 或者 获取多少</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">double</span> uniteValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">double</span> wight, <span class="keyword">double</span> value)</span></span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.id = id;</span><br><span class="line">                    <span class="keyword">this</span>.wight = wight;</span><br><span class="line">                    <span class="keyword">this</span>.value = value;</span><br><span class="line">    </span><br><span class="line">                    <span class="keyword">this</span>.uniteValue = value / wight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来排序的内部类 : 排序的顺序为单位价值从大到小</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Sort</span></span>&#123;</span><br><span class="line">            <span class="comment">// 对传入的 Fruit 数组进行排序, 以单位价值 uniteValue 为排序标准</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(Fruit[] fruits, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = getIndex(fruits, left, right);</span><br><span class="line"></span><br><span class="line">                    quickSort(fruits, left, mid - <span class="number">1</span>);</span><br><span class="line">                    quickSort(fruits, mid + <span class="number">1</span>, right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(Fruit[] fruits, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = left, j = right, t = <span class="number">0</span>;</span><br><span class="line">                Fruit fruit = fruits[ left ];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">double</span>[] fruitUniteValue = <span class="keyword">new</span> <span class="keyword">double</span>[ fruits.length ];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Fruit fruitEach : fruits)&#123;</span><br><span class="line">                    fruitUniteValue[t] = fruitEach.uniteValue;</span><br><span class="line">                    t = t + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> ( fruit.uniteValue &gt;= fruitUniteValue[j] &amp;&amp; i &lt; j )&#123;</span><br><span class="line">                        j = j - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fruits[i] = fruits[j];</span><br><span class="line">                    fruitUniteValue[i] = fruitUniteValue[j];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> ( fruit.uniteValue &lt;= fruitUniteValue[i] &amp;&amp; i &lt; j )&#123;</span><br><span class="line">                        i = i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fruits[j] = fruits[i];</span><br><span class="line">                    fruitUniteValue[j] = fruitUniteValue[i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fruits[i] = fruit;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Fruit[] fruits = <span class="keyword">new</span> Fruit[<span class="number">5</span>];</span><br><span class="line">        Sort sort = <span class="keyword">new</span> Sort();</span><br><span class="line">        <span class="keyword">double</span> nowPackageSize = <span class="number">0</span>; <span class="comment">// 当前背包中的容量</span></span><br><span class="line">        <span class="keyword">int</span> packageInt = <span class="number">0</span>; <span class="comment">// 用来在计算背包容量时用的变量</span></span><br><span class="line"></span><br><span class="line">        fruits[<span class="number">0</span>] = <span class="keyword">new</span> Fruit(<span class="number">1</span>, <span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">        fruits[<span class="number">1</span>] = <span class="keyword">new</span> Fruit(<span class="number">2</span>, <span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        fruits[<span class="number">2</span>] = <span class="keyword">new</span> Fruit(<span class="number">3</span>, <span class="number">6</span>,<span class="number">5</span>);</span><br><span class="line">        fruits[<span class="number">3</span>] = <span class="keyword">new</span> Fruit(<span class="number">4</span>, <span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line">        fruits[<span class="number">4</span>] = <span class="keyword">new</span> Fruit(<span class="number">5</span>, <span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        sort.quickSort(fruits, <span class="number">0</span>, fruits.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;id&quot;</span>+ <span class="string">&quot; &quot;</span> + <span class="string">&quot;wight&quot;</span>  + <span class="string">&quot; &quot;</span> + <span class="string">&quot;value&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="string">&quot;gain&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="string">&quot;uniteValue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Fruit fruit : fruits)</span><br><span class="line">            System.out.println( fruit.id + <span class="string">&quot;\t&quot;</span> + fruit.wight + <span class="string">&quot;\t &quot;</span> + fruit.value + <span class="string">&quot;\t&quot;</span> +  fruit.gain + <span class="string">&quot;\t\t&quot;</span> + fruit.uniteValue);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*******************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nowPackageSize &lt; packageSize)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ( nowPackageSize + fruits[ packageInt ].wight &lt; packageSize )&#123;</span><br><span class="line">                nowPackageSize = nowPackageSize + fruits[ packageInt ].wight;</span><br><span class="line">                fruits[ packageInt ].gain = <span class="number">1</span>; <span class="comment">// 表示获取一份完整的水果</span></span><br><span class="line"></span><br><span class="line">                packageInt = packageInt + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 背包即将超过最高容量</span></span><br><span class="line">            <span class="keyword">if</span> (nowPackageSize + fruits[ packageInt ].wight &gt; packageSize)&#123;</span><br><span class="line">                <span class="comment">// 此时可能已经无法获得一份完整的水果</span></span><br><span class="line"></span><br><span class="line">                fruits[ packageInt ].gain = ( packageSize - nowPackageSize ) / fruits[ packageInt ].wight;</span><br><span class="line"></span><br><span class="line">                nowPackageSize = nowPackageSize + fruits[ packageInt ].wight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = packageInt + <span class="number">1</span>; i &lt; fruits.length; i++)&#123;</span><br><span class="line">            fruits[ i ].gain = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Fruit fruit : fruits)</span><br><span class="line">            System.out.println( fruit.id + <span class="string">&quot;\t&quot;</span> + fruit.wight + <span class="string">&quot;\t &quot;</span> + fruit.value + <span class="string">&quot;\t&quot;</span> +  fruit.gain + <span class="string">&quot;\t\t&quot;</span> + fruit.uniteValue);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        思路详解：</p>
<p>​        从上面的代码可以看到，其中代码的实现大致分为了几个部分 ： 内部类Fruit用来代表水果， 内部类Sort用来排序， 用来实现核心贪心算法的代码。接下来，按照顺序来进行分解：</p>
<p>​        内部类 Fruit ：用来代表水果的类，包含了某个水果对象的重量和价值，方便在后面进行排序时进行使用。</p>
<p>​        内部类 Sort ： 用来对水果进行排序的类，主要包含了 快速排序 的算法，为后面实现贪心算法提供了基础。</p>
<p>​        实现核心贪心算法的代码 ： 这是这个解出这个题目的核心部分，原理是利用贪心算法的原理来对本题进行求解。考虑到在这个题目中，水果是可以被分割。不再需要将整个水果完整的塞入背包中，因此在这个题目中，水果的单位价值( 价值 / 重量 ) 变成了这个题目考虑的第一指标。所以贪心算法被运用到了这个题目中。</p>
<p>​        在这里稍微解释以下贪心算法，以后可能会专门写一篇文章来说说贪心算法。</p>
<p>​        首先，求得每一个可选水果的单位价值，按照单位价值从高到低的顺序进行排序。完成了排序后，进入循环，循环的条件为当前背包中的重量小于背包的总重 并且 依旧存在可以被挑选的水果 。</p>
<p>​        接下来解释循环中的内容：首先进行判断，如果当前价值最高的水果的整体重量小于背包的容量，则将水果整个放入背包中。若当前的背包容量不足以放入一整个水果，则将当前的水果进行拆分，将这个水果的一部分放入背包中。</p>
<h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>​    海盗喝酒问题<br>​    有一群海盗（不多于20人），在船上比拼酒量。过程如下：<br>​    打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。<br>​    再打开一瓶酒平分，又有倒下的，再次重复……<br>​    直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。<br>​    当第4瓶酒平分喝下后，大家都倒下了。<br>​    等船长醒来，发现海盗船搁浅了。<br>​    他在航海日志中写到：“……昨天，我正好喝了一瓶…….奉劝大家，开船不喝酒，喝酒别开船……”<br>​    请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。<br>​    如果有多个可能的答案，请列出所有答案，每个答案占一行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">questionTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a, b, c, d; <span class="comment">// 分别代表 第一轮 第二轮 第三轮 第四轮 剩下的人数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (a = <span class="number">1</span>; a &lt;= <span class="number">20</span>; a++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (b = <span class="number">1</span>; b &lt; a; b++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (c = <span class="number">1</span>; c &lt; b; c++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (d = <span class="number">1</span>; d &lt; c; d++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( <span class="number">1</span> / a + <span class="number">1</span> / b + <span class="number">1</span> / c + <span class="number">1</span> / d == <span class="number">1</span> )</span><br><span class="line">                        System.out.println( a + <span class="string">&quot;  &quot;</span> + b + <span class="string">&quot;  &quot;</span> + c + <span class="string">&quot;  &quot;</span> + d );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        思路详解：</p>
<p>​        上面的代码中最突出的就是拥有着四个循环，这四个循环就是对应着题目中的喝酒轮数。对题目进行分析，可以得知几个比较重要的信息。</p>
<p>​        1、 参与喝酒的人数不超越20人</p>
<p>​        2、 喝酒的次数一共只有4轮，每一次结束之后就会减少一半的人</p>
<p>​        3、 每轮喝酒时都是将一瓶酒平分给所有人</p>
<p>​        4、 船长是最后一个倒下的，且在最后一轮结束后，船长一共喝满了一整瓶酒</p>
<p>​        那么根据上面总结的信息，我们可以知道，程序应该拥有四轮循环。在每次循环中，进行循环的人数总是少于上一轮的人数。而在最后的一次循环时，进行一次判断，使每次进行循环的人数在平分后相加，如果相加之后的结果为一，那么这个结果便是一个符合题目要求的答案。</p>
<h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><p>​    给定整数 n 和 m，满足 n 能被 2m 整除。对于一串连续递增整数数列1、2、3、4，每隔 m 个符号反转一次，最初的符号为’-‘<br>​    例如：<br>​    n = 8, m = 2, 数列就是：-1, -2, +3, +4, -5, -6, +7, +8<br>​    n = 4, m = 1, 数列就是：-1, +2, -3, +4<br>​    求前 n 项和。（2 &lt;= n &lt;= 10^9 ）（时间限制为 1 秒，空间限制32768k）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">questionThree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> Count = <span class="number">0</span>; <span class="comment">// 作为计算是否改修改符号的计数器</span></span><br><span class="line">       <span class="keyword">int</span>[] answerList = <span class="keyword">new</span> <span class="keyword">int</span>[ n ]; <span class="comment">// 作为答案输出的数列</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">           Count = Count + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ( Count &lt; m + <span class="number">1</span> )</span><br><span class="line">               answerList[ i ] = - ( i + <span class="number">1</span> );</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               answerList[ i ] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> ( Count == <span class="number">2</span> * m )</span><br><span class="line">               Count = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println( Arrays.toString( answerList ) );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​        思路详解：</p>
<p>​        首先对题目进行分析，最突出的就是就是按照顺序反转，那么解题思路之一就是使用 有限循环 和 计数器 的方式解题。</p>
<p>​        从题干可知，数字的符号变化是可以通过计数器来控制的。在这个前提下，我们使用一个有限循环，循环次数为输入的 n 的值。由于数是顺序递增，因此在此之前可以先定义一个数组来存放数字，以便在后面对数字进行显示输出。</p>
<p>​        话分两头，让我们回到上文中的循环。在循环中 i 将从 0 开始循环，由于数列的数是从负号开始的，那么每次循环时进行一次判断。设置一个计数器，每次向数列中输入一个数就将计数器加一。当计数器的数量与 m + 1 的值相等时，就将 i + 1 的值输入到数列中，否则就将 - ( i + 1 ) 输入到数列中。</p>
<h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><p>​    某市市长获得了若干批口罩，给定没批口罩的数量，每一批口罩的数目如下：<br>​    9090400    8499400    5926800    8547000    4958200    4422600    5751200    4175600<br>​    6309600    5865200    6604400    4635000    10663400    8087200    4554000<br>​    市长要把口罩分配给室内的 2 所医院，由于物流限制，每一批口罩只能全部分配给其中一家医院。<br>​    市长希望 2 所医院所获得的口罩总数只差越小越好。请你计算这个最小差是多少？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是解决此题的递归方法，但需要一个外置的静态参数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> gap = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">questionFour_wayOne</span><span class="params">(<span class="keyword">int</span> hospitalOne, <span class="keyword">int</span> hospitalTwo, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] mask = &#123; <span class="number">9090400</span>, <span class="number">8499400</span>, <span class="number">5926800</span>, <span class="number">8547000</span>, <span class="number">4958200</span>, <span class="number">4422600</span>, <span class="number">5751200</span>, <span class="number">4175600</span>, <span class="number">6309600</span>, <span class="number">5865200</span>, <span class="number">6604400</span>, <span class="number">4635000</span>, <span class="number">10663400</span>, <span class="number">8087200</span>, <span class="number">4554000</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( k == mask.length )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( gap &gt; Math.abs( hospitalOne - hospitalTwo ) )&#123;</span><br><span class="line">                gap = Math.abs( hospitalOne - hospitalTwo );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println( gap );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        questionFour_wayOne( hospitalOne + mask[ k ], hospitalTwo, k + <span class="number">1</span> );</span><br><span class="line">        questionFour_wayOne( hospitalOne, hospitalTwo + mask[ k ], k + <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是解决此题的动态规划方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">questionFour_wayTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            该方法的主体思想大致为，两家医院，总有一家所分配的口罩量 hospitalOne 大于 口罩总量的一半 （ Total / 2 ）， 另一家所分配的口罩总量 hospitalTwo 小于 口罩总量的一半</span></span><br><span class="line"><span class="comment">            那么题目所求的最小差值就为 = （ hospitalOne - （ Total / 2 ））* 2 = （ （ Total / 2 ） - hospitalTwo ）* 2</span></span><br><span class="line"><span class="comment">            此时题目所求就变为，已知一个背包的容量为 Total / 2 ，求最多可以放入多少的口罩</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span>[] mask = &#123; <span class="number">9090400</span>, <span class="number">8499400</span>, <span class="number">5926800</span>, <span class="number">8547000</span>, <span class="number">4958200</span>, <span class="number">4422600</span>, <span class="number">5751200</span>, <span class="number">4175600</span>, <span class="number">6309600</span>, <span class="number">5865200</span>, <span class="number">6604400</span>, <span class="number">4635000</span>, <span class="number">10663400</span>, <span class="number">8087200</span>, <span class="number">4554000</span> &#125;;</span><br><span class="line"><span class="comment">//        int[] mask = &#123;1, 2, 3, 4, 5, 6, 7&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化背包容量</span></span><br><span class="line">        <span class="keyword">double</span> maskTotal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> value : mask )</span><br><span class="line">            maskTotal = maskTotal + value;</span><br><span class="line">        maskTotal = maskTotal / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Dp 数组， Dp[ j ] 代表 当医院可以接收的口罩上限为 j 时，医院最多可以接收的口罩数量</span></span><br><span class="line">        <span class="keyword">int</span>[] Dp = <span class="keyword">new</span> <span class="keyword">int</span>[ (<span class="keyword">int</span>)maskTotal + <span class="number">2</span> ];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dp 主体 : 当 可接受的口罩上限j的值 大于 这一批的口罩数量时，判断为可以接收。</span></span><br><span class="line">        <span class="comment">// 此时 Dp[j] 做一次判断：当前的数量 和 不接收这批口罩时的最大值加上这批口罩的数量， 选择其中 更大的一方</span></span><br><span class="line">        <span class="comment">// 在循环时，是存在 当前的数量 大于 不接收这批口罩时的最大值加上这批口罩的数量 的情况，因此需要做一次比较判断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> value : mask ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = (<span class="keyword">int</span>)maskTotal; j &gt;= value; j-- )&#123;</span><br><span class="line">                Dp[ j ] = Math.max( Dp[ j ], Dp[ j - value ] + value );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println( Dp[ (<span class="keyword">int</span>)maskTotal ] );</span><br><span class="line">        System.out.println( <span class="number">2</span> * ( maskTotal - Dp[ (<span class="keyword">int</span>)maskTotal ] ) ); <span class="comment">// 2400</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        思路详解：</p>
<p>​        本题可以通过 递归方式 和 动态规划 的方式求解，下面分别讲述两种思路。</p>
<p>​        递归方法：</p>
<p>​        本题的递归方法需要用到一个外置的静态变量 gap ，这个变量用来计算最终的答案。由于我们需要一个使这个值在多次递归中保持不变，因此使用了函数外置静态变量。</p>
<p>​        接下来分解递归参数，首先是两家医院所分到的口罩总数，分别用 hospitalOne 和 hospitalTwo 来表示。其次要明确当前的递归次数，由于题目有mask.length 批口罩，因此当当前的递归次数 k 等于口罩批次时，就应该退出递归。</p>
<p>​        在退出递归时，进行一次判断。如果之前的外置变量 gap 大于当前 hospitalOne和hospitalTwo的差值，那么就将hospitalOne和hospitalTwo的差值的绝对值赋给 gap 。</p>
<p>​        在分析完参数后，接下来对递归内部代码进行分析。首先在进入函数后就应该进行判断，判断条件为当前的递归次数 k 和 口罩批次总数 mask.length。观察是否满足退出递归的条件，来避免无限递归。 若不满足退出递归的条件，那么就对开始递归。由题干可以得知，口罩只能整批整批的分配给某个医院，那么每次分配时就有了两种不同的情况：</p>
<p>​        1、 将这批口罩分配给 hospitalOne</p>
<p>​        2、 将这批口罩分配给 hospitalTwo</p>
<p>​        那么每次进行递归时，就需要分情况递归即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">questionFour_wayOne( hospitalOne + <span class="comment">/* 这批口罩的数量 */</span>, hospitalTwo, k + <span class="number">1</span> );</span><br><span class="line">     questionFour_wayOne( hospitalOne, hospitalTwo + <span class="comment">/* 这批口罩的数量 */</span>, k + <span class="number">1</span> );</span><br></pre></td></tr></table></figure>

<p>​        当然，无论进行哪种情况的递归，都需要将递归次数 k 加 1。</p>
<p>​        当最后一次递归完成后，输出静态变量 gap 的值，此时 gap 的值就是所有分配情况中 hospitalOne 和 hospitalTwo 差值最小的情况。也就是本题所追求的答案。</p>
<p>​        </p>
<p>​        动态规划：</p>
<p>​        对题目分析后，可以将题目拆解为以下的形式。由于口罩的总数是固定的，那么如果某一家医院所分配到的口罩的数量大于总数的一半，那么另一家医院所分配到的口罩总数就必定少于口罩总数的一半。并且，两家医院所得到的口罩数量与口罩总数的一半的差值是相同的。而两家医院口罩的差值就变为了 口罩总数的一半与某一家所得到的口罩数量的差值 乘以 2。</p>
<p>​        由上面的分析，我们可以得到以下的关系式：<br>$$<br>设口罩的总数为 Sum ，则口罩总数的一半就为 Sum / 2，题目所求值为 gap，在此处设定 hospitalOne 大于 hospitalTwo<br>$$</p>
<p>$$<br>gap = hospitalOne - hospitalTwo = 2 * ( hospitalOne - Sum / 2 ) = 2 * ( Sum / 2 - hospitalTwo - Sum / 2 )<br>$$</p>
<p>​        此时这个题目就转化为了一个背包问题：假设一个背包上限为 Sum / 2 的背包，每次装入一批口罩，最多可以装入多少口罩。</p>
<p>​        既然已经明白这个题目已经转化为一个背包问题，那么便可以按照背包问题的方式求解。首先，在这个题目中，每一批口罩都是独一份的不可以重复放入，那么这个题目便是一个 01背包 。</p>
<p>​        那么按照01背包的优化解法，我们先定义一个Dp数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] Dp = <span class="keyword">new</span> <span class="keyword">int</span>[ Sum + <span class="number">2</span> ]; </span><br><span class="line"><span class="comment">// Dp[ j ] ：当 背包的上限为 j 时， 背包中最多可以装入 Dp[ j ] 数量的口罩</span></span><br></pre></td></tr></table></figure>

<p>​        然后对存放口罩的数组进行强化循环，遍历每一批口罩。对于某一批口罩而言，只存在两种情况，即可以放入这批口罩 以及 不能放入这批口罩。若可以放入这批口罩，那么就要进行一次判断，即比较 当前已经放入的口罩的数量 和 背包上限减去这一批口罩后的数量加上这批口罩的数量 两者的数量谁更多。保留数量更大一方，并将其值赋给Dp数组的对应数。</p>
<p>​        最终在遍历结束后，使用 口罩总数的一半 减去 Dp[ 口罩总数的一半 ] 的值乘以 2 便是题目所求的值。</p>
<p>​        日后会专门在写一篇文章来阐述背包问题的相关解法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/06/%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/06/%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-06 21:30:36" itemprop="dateCreated datePublished" datetime="2021-11-06T21:30:36+08:00">2021-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-20 12:52:41" itemprop="dateModified" datetime="2021-11-20T12:52:41+08:00">2021-11-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>​        这篇文章来讨论排序相关的内容，每种排序将会分为 算法原理， 代码实现 和 参考 三个板块来描述。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>​        如标题所言，这个板块来讨论快速排序（ QuickSort ）。</p>
<p>​        首先，快速排序 QuickSort 可以视作冒泡排序的优化版。这次对于快速排序的解释将从 <strong>算法原理</strong>  和 <strong>代码实现</strong> 两个部分来解释。</p>
<p>​        快速排序,说白了就是给基准数据找其正确索引位置的过程。</p>
<p>​        好了，下面的这一部分不用看，采自 <a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/quick-sort-2.html">菜鸟教程</a> 。</p>
<p>​        快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<h6 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h6><p>​        快速排序 使用的是核心思想之一便是 分治算法 。</p>
<p>​        每次设定一个目标数组内的元素为基准值，以这个值为对象，将其他的元素与这个值一一比较。最终使得这个基准值左侧的元素都小于这个基准值，基准值右侧的元素都大于这个基准值。</p>
<p>​        接下来以一个具体的 int 数组为例子来逐步说明算法的运行原理。</p>
<p>​        输入数组：</p>
<table>
<thead>
<tr>
<th align="center">15</th>
<th align="center">68</th>
<th align="center">47</th>
<th align="center">24</th>
<th align="center">11</th>
<th align="center">3</th>
<th align="center">98</th>
<th align="center">67</th>
</tr>
</thead>
</table>
<p>​        第一步：确认一个元素作为这次比较的基准值，此处以数组左侧第一个元素 <em>15</em> 作为基准。使用一个临时变量 temp 来储存这个基准值，并设置两个位置指针，左指 left 以及 右指 right 。左指最开始指向数组的第一个元素，右指最开始指向数组的最后一个元素。</p>
<p>​        第二步：从右指所对应的元素开始，将对应元素和基准值进行比较。若比基准值大，则右指 right 向左移动一位，继续比较 ； 若比基准值小，则执行下一步。</p>
<p>​        第三步：现在，目前的右指所对应的元素为 3 ，小于作为基准值的 temp 。则将目前右指所对应的元素赋给当前左指所对应的元素。那么，进行赋值操作后的数组就变为了下面的样子：</p>
<table>
<thead>
<tr>
<th align="center">3</th>
<th align="center">68</th>
<th align="center">47</th>
<th align="center">24</th>
<th align="center">11</th>
<th align="center">3</th>
<th align="center">98</th>
<th align="center">67</th>
</tr>
</thead>
</table>
<p>​        从上方的数组变化可以看出，第三步将 右指所对应的元素 3 赋给了 左指所对应的元素 15。</p>
<p>​        在赋值完成后，如果 左指left 小于 右指right 便继续比较。但需要更变方向，从数组的左值所对应的元素开始和基准值进行比较，若比基准值小，则左指向右移动移动一位，继续比较； 若比基准值大，则执行下一步。</p>
<p>​        第四步：现在，目前的左值所对应的元素为 68 ，大于作为基准值的 temp。则将目前左指所对应的元素赋给当前右指所对应的元素。那么，进行赋值操作后的数组就变为了下面的样子：</p>
<table>
<thead>
<tr>
<th align="center">3</th>
<th align="center">68</th>
<th align="center">47</th>
<th align="center">24</th>
<th align="center">11</th>
<th align="center">68</th>
<th align="center">98</th>
<th align="center">67</th>
</tr>
</thead>
</table>
<p>​        从上方的数组变化可以看出，第四步将 左指所对应的元素 68 赋给了 右指所对应的元素 3。</p>
<p>​        在赋值完成后，如果 左指left 小于 右指right便回到第二步，继续比较。不断循环，直到左指left 大于 右指right 时结束循环。对上方的数组进行操作后，数组变为下面的样子：</p>
<table>
<thead>
<tr>
<th align="center">3</th>
<th align="center">11</th>
<th align="center">47</th>
<th align="center">24</th>
<th align="center">47</th>
<th align="center">68</th>
<th align="center">98</th>
<th align="center">67</th>
</tr>
</thead>
</table>
<p>​        此时的 左指 与 右指 都指向数组的第三个元素 47，此时 左指 不再大于 右指 循环已经结束，进入最后一步。</p>
<p>​        第五步：对于这个结束循环的数组，我们可以发现之前的基准值并不在这个数组当中，因此需要使基准值重新回到数组当中。</p>
<p>为了使得完成这次排序的目的( 使得基准值左侧的元素都小于基准值，基准值右侧的元素都大于基准值 )，需要将储存在临时变量temp中的基准值赋给当前 左指left ( 当然，右指right 也可以，此时左右指所对应的位置相同 )。</p>
<p>​        即：Num[i] = temp;</p>
<p>​        </p>
<p>​        在完成上方的所有步骤后，一次快速排序就完成了，但若想将一个数组完全顺序排列，就需要进行多次的快速排序。为此就需要用到分治的思想，每次排序算法都可以确定数组中一个元素的具体位置，那么以这个位置为基准，将其左侧和右侧的元素视为一个数组传入排序函数，进行排序。</p>
<p>​        采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。</p>
<p>​        </p>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><p>​        按照上方算法原理的推论，借此来书写示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] Num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">       <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">           <span class="comment">// 通过getIndex函数获取mid的值，作为后续排序的基准</span></span><br><span class="line">           <span class="keyword">int</span> mid = getIndex(Num, left, right);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 因为mid对应位置的元素已经完成排序，所以传入函数时不传入mid本身</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 对mid左侧的元素进行排序</span></span><br><span class="line">           quickSort(Num, left, mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 对mid右侧的元素进行排序</span></span><br><span class="line">           quickSort(Num, mid + <span class="number">1</span>, right);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * int getIndex(int[] Num, int left, int right) 用于确定数组中一个确定位置</span></span><br><span class="line"><span class="comment">     * 传入一个整形数组Num，左指left，右指right 传出一个int型的数字</span></span><br><span class="line"><span class="comment">     * 传出的数字是一个完成排序的元素在数组Num中所对应的位置，返回的这个位置将作为后续排序的基准</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] Num, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = Num[left]; <span class="comment">// 每轮中用来比较的元素</span></span><br><span class="line">        <span class="keyword">int</span> i = left, j = right; <span class="comment">// i 代表数组的左指， j 代表数组的右指</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里对第 24 到 36 行的代码进行解释</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123; <span class="comment">// 循环条件： 传入的左指小于右指</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在比较时从数组的右侧开始比较</span></span><br><span class="line">            <span class="comment">// 数组中第 j 个值 大于等于 temp 这个用于比较的值</span></span><br><span class="line">            <span class="keyword">while</span> (Num[j] &gt;= temp &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                j = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此处说明 数组中的第 j 个值 小于 temp 这个用于比较值 或者 左指不再小于右指</span></span><br><span class="line">            Num[i] = Num[j]; <span class="comment">// 将数组中的第 j 个值(这个值小于temp这个比较值) 赋给数组左指所对应的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在下面的第 33 到 36 行的原理和上方相同，只不过将比较条件从大于temp变作小于temp</span></span><br><span class="line">            <span class="keyword">while</span> (Num[i] &lt;= temp &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Num[j] = Num[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处需要将temp的值赋给数组当前左值所对应的位置，此时对于temp这个比较值而言，左侧的数皆小于temp，右侧的值皆大于temp</span></span><br><span class="line">        Num[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(temp + &quot;\t&quot; + Arrays.toString(Num) );</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span>[] Num = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        QuickSort quickSort = <span class="keyword">new</span> QuickSort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            Num[i] = random.nextInt(<span class="number">100</span>); <span class="comment">// 生成 0 - 100 范围内的随机数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println( Arrays.toString(Num) );</span><br><span class="line"></span><br><span class="line">        Num = quickSort.quickSort(Num, <span class="number">0</span>, Num.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">&quot;排序后&quot;</span> + <span class="string">&quot;\n&quot;</span> + Arrays.toString( Num ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h6><p>​        <a target="_blank" rel="noopener" href="https://blog.csdn.net/nrsc272420199/article/details/82587933">CSDN ：快速排序—(面试碰到过好几次)</a></p>
<p>​        <a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/quick-sort-2.html">菜鸟教程——快速排序</a></p>
<p>​        <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&fromid=2084344&fr=aladdin">百度百科——快速排序</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/26/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/26/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/" class="post-title-link" itemprop="url">学习笔记——算法设计的学习笔记 One</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-26 16:57:53" itemprop="dateCreated datePublished" datetime="2021-09-26T16:57:53+08:00">2021-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-03 01:01:38" itemprop="dateModified" datetime="2021-10-03T01:01:38+08:00">2021-10-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="屁话"><a href="#屁话" class="headerlink" title="屁话"></a>屁话</h2><p>​    这是算法课上的弄到的题目，一共7个，加上 附加的 汉诺塔 和 背包问题，下面对他们进行解答（给上题目）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* Q1. 利用递归函数计算 n 的阶乘</span><br><span class="line">* Q2. 书写一个斐波拉契数列，输入一个正整数 K （<span class="number">0</span> &lt; K &lt; <span class="number">47</span>），求对应斐波拉契数列的第K个数</span><br><span class="line">* Q3. 斐波拉契数列的比值 F(n) / F(n+<span class="number">1</span>) 的值会趋近于黄金分隔，给定正整数N，验证此项兴致</span><br><span class="line">* Q4. 小明爬楼梯，一次只能上一级 或者 两级台阶，一共有 N 级台阶，求小明有多少种爬台阶的方法</span><br><span class="line">* Q5. 小明爬楼梯，一次可以上一级，两级 或者 N级，求小明有多少种爬台阶的方法</span><br><span class="line">* Q6. 整数因子分解问题：计算正整数 N 有多少种因子大于<span class="number">1</span>的不同的分解式</span><br><span class="line">* Q7. 给定整数 N， 取若干个 <span class="number">1</span> 到 N 的整数可求和等于整数 M， 编程求出所有组合的个数</span><br><span class="line">*</span><br><span class="line">* Qs1. 汉诺塔问题</span><br><span class="line">* Qs2. 背包问题 https:<span class="comment">//zhuanlan.zhihu.com/p/93857890</span></span><br></pre></td></tr></table></figure>



<h2 id="题目-和-题解"><a href="#题目-和-题解" class="headerlink" title="题目 和 题解"></a>题目 和 题解</h2><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>​    利用递归函数计算 n 的阶乘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Q1</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> N * Q1(N -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解析：</p>
<p>​    这个没啥好说的，对于 N 的阶乘，设定当  N = 1 时，返回 1。否则就用 N 去乘以 Q1( N - 1 ) 的值。</p>
<p>​    例如，当 N = 3 时，就有 3 * Q1( 2 ) 而 Q1( 2 )  = 2 * Q1( 1 )  而 Q1( 1 ) = 1，最终会形成算式 3 * 2 * 1并输出。</p>
<h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>​    书写一个斐波拉契数列，输入一个正整数 K （0 &lt; K &lt; 47），求对应斐波拉契数列的第K个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Q2</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">0</span>, B = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> C = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= N;i++)&#123;</span><br><span class="line">        C = A + B;</span><br><span class="line">        A = B;</span><br><span class="line">        B = C;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递归书写 斐波拉契数列 的方法，不考虑时间和空间的占用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Q2_C</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Q2_C(N - <span class="number">1</span>) + Q2_C(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解析：</p>
<p>​    书写<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145?fr=aladdin"><strong>斐波拉契数列</strong></a>本身并不困难，参考上方代码的函数Q2_C。但是对于本题目，题干中划定了 正整数K 的取值范围，如果对于函数Q2_C而言，当 K 增加到30左右时，就可以明显的感受到计算结果所需要的时间增加。因此需要对Q2_C函数进行优化，提高其工作效率。    函数Q2 就是对Q2_C 的优化改良，相较于Q2_C ，函数Q2在计算所需的时间和空间的效率上均有明显的提升，其思想在于：</p>
<p>​    已知斐波拉契数列的第一个数为0，第二个数为1，后面的数都是前面两个数的相加和，那么 定义变量 A 为数列的第一个数(A = 0)，变量 B 为数列的第二个数(B = 1)，变量 C 为 A 和 B 的相加和。</p>
<p>​    书写循环，令循环从 2 开始(前面两个数已知为A 和 B)，到 N 截至。循环内，使得 C = A + B ( C是A 和 B的相加和 )，然后让 A 和 B 向前移动，令 A = B，B = C ( 相当于A 和 B都向前移动了一位数 )。</p>
<p>​    例如，当N = 10时，第一次循环 C = A + B = 1 ，令A 和 B前移，A = B = 1，B = C = 1 ( 此时A就代表第二个数，B就代表第三个数 )，如此往复，直到当 N = 10时，输出 C 的值即可，C 的值就是对应斐波拉契数。</p>
<h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><p>​    斐波拉契数列的比值 F(n) / F(n+1) 的值会趋近于黄金分隔，给定正整数N，验证此项性质</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Q3</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] Num = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">0</span>,B = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> C = <span class="number">0</span>;</span><br><span class="line">    Num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一部分：计算斐波拉契数列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)&#123;</span><br><span class="line">        Num[i] = A + B;</span><br><span class="line">        A = B;</span><br><span class="line">        B = Num[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println( Arrays.toString(Num) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二部分：验证斐波拉契数列 和 黄金分割 之间的关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)</span><br><span class="line">        C = (<span class="keyword">double</span>) Num[i - <span class="number">1</span>] / Num[i];</span><br><span class="line"></span><br><span class="line">    System.out.println( String.format(<span class="string">&quot;%.8f&quot;</span>,C) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解析：</p>
<p>​    对于这个题目，要根据斐波拉契数列 和 黄金分割的关系解题。如题干所言，相邻两个斐波那契的比值是随序号的增加而逐渐趋于黄金分割比的，因此，如果要进行验证，就要对此下手。</p>
<p>​    题解被分为了两部分，第一部分计算斐波拉契数列，第二部分验证斐波拉契数列 和 黄金分割 之间的关系。</p>
<p>​    第一部分：这一部分要计算斐波拉契数列，因为要在第二部分验证 斐波拉契数列 和 黄金分隔 之间的关系时使用，因此使用一个数组Num 来存放斐波拉契数。计算斐波拉契数列的方式采用是 <strong>问题2</strong> 中的优化解法，只不过使用了数组来替代 C 的位置。</p>
<p>​    第二部分：这一部分用来验证 斐波拉契数列 和 黄金分割 之间的关系，使用循环来输出 斐波拉契数列 相邻两项的比值即可。要注意的是，此处应该使用强制类型转换，将 整型 转换为 浮点型，否则会损失一部分值。</p>
<p>​    关于如何控制输出的浮点位数:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/laphome/p/10680436.html">Java保留N位小数</a></p>
<p>​    </p>
<h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><p>​    小明爬楼梯，一次只能上一级 或者 两级台阶，一共有 N 级台阶，求小明有多少种爬台阶的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Q4</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Q4(N - <span class="number">1</span>) + Q4(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解析：</p>
<p>​    基于本题的题干可知，小明(或者是青蛙之类的其他什么东西)在爬楼梯时，永远只有两种选择，即 <strong>爬一个阶梯</strong> 或者 <strong>爬两个阶梯</strong>。那么，就可以从这里入手分析题目。</p>
<ol>
<li><p>​    将阶梯的数量记为 N，<strong>爬一个阶梯</strong> 记为 N - 1，<strong>爬两个阶梯</strong> 记为 N - 2，每次爬阶梯时进行一次计算，当 N 只剩下一级阶梯 (N = 1) 或 爬完所有阶梯(N = 0) 时，返回 1。</p>
</li>
<li><p>​    当阶梯的数量为 1 时，爬阶梯的方法只有 <strong>爬一个阶梯</strong> 这一种。</p>
</li>
<li><p>​    当阶梯的数量为 2 时，爬阶梯的方法就有 <strong>爬一个阶梯</strong> 和 <strong>爬两个阶梯</strong> 这两种，这代表了两种不同的分支，即 <strong>每次只爬一个阶梯</strong> 和 <strong>每次只爬两个阶梯</strong> 。</p>
</li>
<li><p>​    当阶梯的数量大于 2 时，无论是爬一个阶梯还是爬两个阶梯都无法一次性爬完台阶，那么此时就要去计算 N 下两种分支的不同结果，即 N - 1 和 N - 2 是否可以<strong>一次性爬完台阶</strong>( 计算完后N的值为 0 或 1 )，否则就继续计算 N - 1 和 N - 2 的分支，直到两条分支上N的值都被减为零或一时，所有的情况统计完毕。</p>
</li>
<li><p>​    爬台阶的方法 = 所有分支上返回结果的总和。</p>
<p>   例如：当 N = 5 时，爬阶梯的方法 = Q4( 5 )   = Q4( 4 ) + Q4( 3 ) </p>
<p>​                                                                               = Q4( 3 ) + Q4( 2 ) + Q4( 2 ) + Q4( 1 ) </p>
<p>​                                                                               = Q4( 2 ) + Q4( 1 ) + Q4( 1 ) + Q4( 0 )  + Q4( 1 ) + Q4( 0 ) + Q4( 1 )</p>
<p>​                                                                               = Q4( 1 ) + Q4( 0 ) + Q4( 1 ) + Q4( 1 ) + Q4( 0 ) +  Q4( 1 ) + Q4( 0 ) + Q4( 1 )</p>
<p>​                                                                               = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 8</p>
</li>
</ol>
<h4 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h4><p>​    小明爬楼梯，一次可以上一级，两级 或者 N级，求小明有多少种爬台阶的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Q5</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            A = A + Q5( N - i );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解析：</p>
<p>​    这题原本爬楼梯的生物是青蛙，被我变成了小明……..</p>
<p>​    可以看出，这一题是对上面<strong>问题4</strong>的派生，那么首先就要考虑，是否可以套用原本题目的代码。查看题干，可以得知，与上一题相比，小明( 或者是青蛙？)这次爬台阶时，可以想爬多少级就爬多少级。</p>
<p>​    那么，问题4中的第一条分析就是可以套用到这里的。</p>
<ol>
<li><p>​        将阶梯的数量记为 N，<strong>爬一个阶梯</strong> 记为 N - 1，<strong>爬两个阶梯</strong> 记为 N - 2，<strong>爬M个台阶</strong> 记为 N - M，每次爬阶梯时进行一次计算，当 N 只剩下一级阶梯 (N = 1) 或 爬完所有阶梯(N = 0) 时，返回 1。</p>
</li>
<li><p>​        当阶梯的数量为 1 时，爬阶梯的方法只有 <strong>爬一个阶梯</strong> 这一种。</p>
</li>
<li><p>​        当阶梯的数量为 2 时，爬阶梯的方法就有 <strong>爬一个阶梯</strong> 和 <strong>爬两个阶梯</strong> 这两种，这代表了两种不同的分支，即 <strong>每次只爬一个阶梯</strong> 和 <strong>每次只爬两个阶梯</strong> 。</p>
</li>
<li><p>​        当阶梯的数量大于2时，爬阶梯的方法出现了多分支即 <strong>爬一个阶梯</strong> 、 <strong>爬两个阶梯</strong>  、<strong>爬三个阶梯</strong> …. 直到 <strong>爬N个阶梯</strong>。那么可以得到一个结论，对于N级台阶，有N个可以进行计算的分支。和问题4中相同，直到每条分支上的N值减为零或一，返回结果，所有情况统计完毕。</p>
</li>
<li><p>​        对于如何实现计算多分支，可以通过循环处理，循环从 1 开始，直到N结束。( 代表选择爬几个台阶，例如 i = 1时，对应的就是爬一个台阶 )</p>
</li>
<li><p>​        爬台阶的方法 = 所有分支上返回结果的总和。</p>
<p>​        例如：当 N = 5 时，爬阶梯的方法 = Q5( 3 )  = Q5( 2 ) + Q5( 1 ) +  Q5( 0 )</p>
<p>​                                                                                   = Q5( 1 ) + Q5( 0 ) + Q5( 1 ) +  Q5( 0 )</p>
<p>​                                                                                   = 1 + 1 + 1 + 1 = 4</p>
</li>
</ol>
<h4 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h4><p>​    <a target="_blank" rel="noopener" href="https://blog.csdn.net/elma_tww/article/details/85051340">整数因子分解问题</a>：计算正整数 N 有多少种因子大于1的不同的分解式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Q6</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (N % i == <span class="number">0</span>)</span><br><span class="line">                Answer = Answer + Q6(N / i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Answer + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//问题6 的 变种写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Q6_C</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Answer = <span class="number">1</span>,i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i * i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (N % i == <span class="number">0</span>)</span><br><span class="line">                Answer += Q6_C(i) + Q6_C(N / i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i * i == N)</span><br><span class="line">            Answer += Q6_C(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解析：</p>
<p>​    如果熟悉分支法，那么就可以看出本题是个经典的分支题目。但看上面的代码可知，我明显是个哈批，不会分支，因此在这里尝试其他的解法。</p>
<p>​    分析题干可以得到多个重要的信息：</p>
<ol>
<li>​    既然是因式分解，那么答案中的数都是可以被 N 给整除的。</li>
<li>​    对于 i 和 N / i 可以视为不同的两对答案，例如当N = 12时，2 * 6 和 6 * 2 视为两组不同的答案。</li>
<li>​    对于 N 因式分解的答案，所有因子都是大于 2 的( 除了N本身 )，因此在我们使用循环来处理题目时，循环的范围为 2 到 N ( 不包括N本身，因为在本题中，N的本身也属于一个答案 )，由于 N 和 N / i 被视为不同的答案，因此可以只循环一遍，只对 N / i 或者 N / (N - i) 进行讨论。</li>
</ol>
<p>​    对本题进行分析后可以发现，这题其实和问题5中的情况其实并没有什么区别。对于本题而言，依旧要讨论其所有的分支情况，将分支情况的结果相加即可得到最终的答案。当然，本题的分支讨论比较特殊，答案需要满足被N整除的条件，另外，在返回结果时，需要在结果上加一。因为，我们在使用循环时，并没有讨论 N = N * 1 这种算作一种的特殊答案。</p>
<p>​    那么还是和上题一样，最终的结果就是所有分支结果返回的总和。</p>
<p>​    例如：Q6( 8 ) = Q6( 4 ) + Q6( 2 ) + 1</p>
<p>​                            = Q6( 2 ) + 1 + 1 + 1</p>
<p>​                            = 1 + 1 + 1 + 1 = 4</p>
<p>​    最终 Q6( 8 ) 的结果就为4</p>
<h4 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h4><p>​    <a target="_blank" rel="noopener" href="https://blog.csdn.net/Sam_yw/article/details/78050788">给定整数 N， 取若干个 1 到 N 的整数可求和等于整数 M， 编程求出所有组合的个数</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Q7</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] Dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">2</span>][M + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 此处 Dp 数组的含义是 i 个数（从 1 到 i）的和是 j 的组合数</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 初始化 Dp 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)</span><br><span class="line">            Dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= i)&#123;</span><br><span class="line">                    Dp[i][j] = Dp[i - <span class="number">1</span>][j - i] + Dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    Dp[i][j] = Dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解析：</p>
<p>​    本题看上去是和上面的问题6相似，那么当然的，是否能把问题6的代码修改后套用到问题7上，当当当当当当当当当当当当当当当当当当当当当当当然不可以!</p>
<p>​    So，why？Why 不能把代码套用？对本题题干进行分析可知几个重要信息：</p>
<ol>
<li>​    答案中所包含的数所加和的值为整数 M。</li>
<li>​    对于 1 到 N 中的数，在进行加法运算时，每个数只能使用一次。例如：当 N = 6，M = 8时，不能使用 2 + 2 + 2 + 2 作为答案，这也是为什么不能将问题6中的代码套用到问题7上。</li>
</ol>
<p>​    对题目有基本认识后，可以看出来，这是一个01背包问题的变种，以下，我们试图通过用背包问题的解法来解决这个问题：</p>
<p>​    以 N = 6，M = 8 为例子，我们将 M 看作一个有 8 个容量的背包，将 1 ~ N 个数 看作 对应重量的为 1 ~ N 的物品( 例如 数字2 就代表 有一个 重量为2 的物品 )。 我们认为每件物品只有一件，不能重复使用，当背包中物品的重量 与 背包本身的容量 正好相等时，认为背包中的组合为一个正确答案( 例如 1 + 3 + 4 = 8，则 1，3，4为一组正确答案 )。</p>
<p>​    那么，我们设定一个名为Dp的二维数组，对于 Dp [ i ] [ j ] , i 代表着 N 的值，j 代表着 M 的值，Dp [ i ] [ j ] 代表 对应的答案数量，进行计算后可以得到：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>1</strong></th>
<th align="center"><strong>2</strong></th>
<th align="center"><strong>3</strong></th>
<th align="center"><strong>4</strong></th>
<th align="center"><strong>5</strong></th>
<th align="center"><strong>6</strong></th>
<th align="center"><strong>7</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>​    在表中，第一行的值，为N( i ) 的值 ； 第一列的值，为M( j ) 的值。</p>
<p>​    结合表和我们在上方对题目的分析，我们可以得到如下的关系：</p>
<ol>
<li><p>​    当 N &gt; M 时 ( 即代表 有些物品的重量大于背包的容量 或者 背包的容量不足以装下其中部分的物品 )，可以得到一个递推公式：                                                                           Dp [ N ] [ M ] = Dp [ N - 1] [ M ] </p>
<p>​    对上方的递推公式进行分析，Dp [ N ] [ M ] 代表着最后答案的数量( 同时意味着将重量为 N 的物品放入背包 M )，而Dp [ N - 1 ] [ M ]代表不将重量为 N 的物品放入背包M。</p>
<p>​    当N &gt; M时，可以看作物品的重量大于当前背包的容量。因此，无论如何不能再将物品放入背包了,所对应最后答案的数量就是不将重量为 N 的物品放入背包时的值，所以 Dp [ N ] [ M ] 的值就等于Dp [ N - 1 ] [ M ] 。</p>
</li>
<li><p>​    当 N &lt;= M 时( 即代表 当前物品可以放入背包，小于背包的容量 )，可以的得到一个递推公式：<br>​                                                       Dp [ N ] [ M ] = Dp [ N - 1] [ M ]  + Dp [ N - 1] [ M - N ]</p>
<p>​    对上方的递推公式进行分析，Dp [ N ] [ M ] 代表着最后答案的数量( 同时意味着将重量为 N 的物品放入背包 M )、 Dp [ N - 1 ] [ M ]代表不将重量为 N 的物品放入背包M，而 Dp [ N - 1] [ M - N ] 代表着将重量为 N 的物品放入背包 M( 其中N - 1代表将重量为 N 的物品放入背包所需要的空间，M - N 代表背包的容量减小N的值 )。</p>
<p>​    当 M &gt;= N 时，可以看作当前背包的容量大于物品的重量。因此，只要保证背包中还剩余有放入重量为 N 的物品的空间，就可以将物品放进去。因此，最后所对应答案的数量就是 不将重量为 N 的物品放入背包时的值 加上 将重量为 N 的物品放入背包时的值。</p>
<p>​    所以 Dp [ N ] [ M ] 的值等于 Dp [ N - 1] [ M ]  + Dp [ N - 1] [ M - N ]。</p>
</li>
</ol>
<h4 id="附加1：汉诺塔"><a href="#附加1：汉诺塔" class="headerlink" title="附加1：汉诺塔"></a>附加1：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37873310/article/details/80461767">汉诺塔</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Qs_C</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 基本的解题思路为，将原本多个盘子视作两个盘子（ 最顶部的盘子 和 除顶部盘子外所有的盘子 ）并对其进行移动</span></span><br><span class="line">        <span class="comment">// 而两个盘子从 A -&gt; C 的过程相对简单，只需要三步即可（A -&gt; B, A -&gt; C, B -&gt; C）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;将盘子从&quot;</span> + a + <span class="string">&quot; -&gt; &quot;</span> + c ); <span class="comment">// 当只有一个盘子时，可以直接将盘子从 A 移动到 C</span></span><br><span class="line">            Answer++;</span><br><span class="line">            <span class="keyword">return</span> Answer;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 此时视作除顶上的盘子外，下方所有盘子是一个盘子，总共只有两个盘子</span></span><br><span class="line">            <span class="comment">// 则将最顶部的盘子从 A 移动到 B 因此，参数的中的顺序为 a，c，b</span></span><br><span class="line">            Answer = Answer + Qs_C(N - <span class="number">1</span>, a, c, b );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 紧接上方，此时将之前视为一个盘子的部分从 A 移动到 C，这代表这进行了移动，因此Answer++</span></span><br><span class="line">            System.out.println(<span class="string">&quot;将盘子从&quot;</span> + a + <span class="string">&quot; -&gt; &quot;</span> + c );</span><br><span class="line">            Answer++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后将之前移动到 B 上的盘子移动到 C 上，因此 参数为 b，a，c</span></span><br><span class="line">            Answer = Answer + Qs_C(N - <span class="number">1</span>, b, a, c );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解析：</p>
<p>​    这个问题起源于印度，具体怎么来的自己百度。总之，简述一下题目：有三个柱子A，B，C，在A柱上有N个圆盘，这N个圆盘从上到下越来越大。这时，需要将所有圆盘从A柱移动到C柱上，一次只能移动一个圆盘，并且小圆盘不能放在大圆盘的下方。如下图：</p>
<p>​    <img src="/2021/09/26/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/20180526185900422.png" alt="汉诺塔"></p>
<p>​    我们要将A柱上的盘子都移动到C柱上,好吧，这是一个相当墨迹的过程。就拿上面的图而言，我们要移动整整64个盘子，这不是可以直接操作的。</p>
<p>​    那么，我们对这个问题进行一个简化。如果，A柱上只有一个盘子呢？哦，这相当简单，是个哈批都可以做到，直接从A柱上拿到C柱就行了( 即 A -&gt; C 或者 A -&gt; B -&gt; C )。</p>
<p>​    好了，让我们加大一点难度。此时A柱上有两个盘子，这看起来也不怎么难，同样也只需要简单几步。嗯，首先将第一个盘子从A柱上移动到B柱上，再将第二个盘子从A柱上移动到C柱上，最后将B柱上的盘子移动到C柱上( A -&gt; B, A -&gt; C, B -&gt; C )。好耶，我们成功了，只要3步，不怎么难嘛~~</p>
<p>​    再让我们加大一点难度。现在有A柱上有64个圆盘，哦不，现在就有一些麻烦了。那么我们转换一下思路，我们将64个圆盘看作2个圆盘，将其中63个圆盘视作一个整体如何？现在我们认为只有两个圆盘，即 最上方的圆盘 和 除最上方圆盘外的其他63个圆盘视为一个整体的一个圆盘。</p>
<p>​    那我们操作时，就按照和两个圆盘时的操作相同。但是其实不止2个盘子，所以我们需要使用递归来操作题目，每次只考虑两个盘子，不断重复两个盘子时的操作( 具体可以看代码中的注释 )，最终即可解出这个 <del>该死的</del> 古老的算数问题。</p>
<p>​    好的，现在肯定有人看了代码要说了，你这每一步代码有点绕啊。我这只能说，不要在意这些问题。因为如果你要解释代码的每一步过程，那会非常乱，两层递归是相当麻烦的，最终自己也会被绕晕。那么为什么不把复杂的过程交给程序，我们只负责最简单的部分就好，我们按照最直接的理解就行了。</p>
<h4 id="附加2：背包问题"><a href="#附加2：背包问题" class="headerlink" title="附加2：背包问题"></a>附加2：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/93857890">背包问题</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Qs2</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] Dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">2</span>][M + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 Dp数组</span></span><br><span class="line">        <span class="comment">// 此处代表 当背包只能存放物品1时的值，此处假定值为1，不同问题的值不相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)</span><br><span class="line">            Dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ( j &gt;= i)&#123;</span><br><span class="line">                    Dp[i][j] = Dp[i - <span class="number">1</span>][j - i] + Dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    Dp[i][j] = Dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    解析：</p>
<p>​    对于本题，如果采用暴力穷举的方式，每件物品都存在装入和不装入两种情况。因此，总的时间复杂度，呵呵，操蛋的不敢相信，这是绝对不可接受的，除非你的电脑是天河二号。</p>
<p>​    而使用动态规划可将复杂度骤降，我们的目标是书包的总价值，而变量是物品和书包的限重，所以我们可定义状态Dp：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, <span class="number">0</span>&lt;=i&lt;=N, <span class="number">0</span>&lt;=j&lt;=W</span><br></pre></td></tr></table></figure>

<p>​    那么我们可以将数组中Dp [ 0 ] [ j ] 初始化为0，表示前 0 个物品( 既没有物品 ) 装入书包的最大价值为0。那么当 i &gt; 0 时Dp [ i ] [ j ] 有两种情况：</p>
<ol>
<li>​    不装入第 i 间物品，即 Dp [ i - 1 ] [ j ]。</li>
<li>​    装入第 i 件物品( 前提是能装下 )，即 Dp [ i - 1 ] [ j - w[ i ] ] + v[ i ]。( w[ i ] 代表 物品i的重量，v[ i ] 代表 物品i的价值 )</li>
</ol>
<p>​    这样我们就可以得到一个状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i−<span class="number">1</span>][j], dp[i−<span class="number">1</span>][j−w[i]]+v[i]) <span class="comment">// j &gt;= w[i] 代表 书包容量j大于物品i的重量</span></span><br></pre></td></tr></table></figure>

<p>​    由上述状态转移方程可知，<code>dp[i][j]</code>的值只与<code>dp[i-1][0,...,j-1]</code>有关，所以我们可以采用动态规划常用的方法（滚动数组）对空间进行优化（即去掉 Dp 的第一维，把Dp数组变化为一维数组）。需要注意的是，为了防止上一层循环的<code>dp[0,...,j-1]</code>被覆盖，循环的时候 j 只能<strong>逆向枚举</strong>（空间优化前没有这个限制）。当然，这是一个相当麻烦的办法，额，我是指思想方面。</p>
<p>​    伪代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01背包问题伪代码(空间优化版)</span></span><br><span class="line">dp[<span class="number">0</span>,...,W] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,...,N</span><br><span class="line">    <span class="keyword">for</span> j = W,...,w[i] <span class="comment">// 必须逆向枚举!!!</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j−w[i]]+v[i])</span><br></pre></td></tr></table></figure>

<p>​    从上面可以得知，动态规划的核心思想在于避免重复计算。这个思想在背包问题中体现的淋漓尽致，第 i 件物品装入或者不装入而获得的最大价值完全可以由前面 i - 1 件物品的最大价值决定，而暴力枚举忽略了这个事实。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/10/Java%E5%BA%93%E4%B8%AD%E7%9A%84LocalDate%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/10/Java%E5%BA%93%E4%B8%AD%E7%9A%84LocalDate%E7%B1%BB/" class="post-title-link" itemprop="url">Java库中的LocalDate类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 23:44:44" itemprop="dateCreated datePublished" datetime="2021-09-10T23:44:44+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-11 15:19:16" itemprop="dateModified" datetime="2021-09-11T15:19:16+08:00">2021-09-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    在Java的标准类库中，Date类的实例有一个特别的状态，即 <strong>特定的时间点</strong></p>
<p>​    尽管在使用Date类不必在意这一点，但Date时间是用距离一个固定时间点的毫秒数（可正可负）表示的，这个时间点就是所谓的 <strong>纪元</strong> ，即UTC（Coordinated Universal Time 国际协调时间）时间1970年1月1日00：00：00。</p>
<p>​    但是，Date类对于处理人类记录日期的日历信息并不是那么有用，如“December 31，1999”，这种特定的日期描述遵循了世界上大多数地区使用的Gregorian阳历。但是，同样的这个时间点采用中国或者希伯来的阴历就不那么准确了。</p>
<p>​    对此Java的类库设计者决定将保存时间与给时间点命名分开。Java类标准库分别包含了两个类：一个是用来表示时间点的Date类，另一个是用大家熟悉的日历表示法表示日期的LocalDate类，当然，在Java8以后，引入了另外一些类来处理日期和时间的不同方面。</p>
<p>​    将时间度量与日历分开是一种很好的面向对象设计，通常，最好使用不同的类来表示不同的概念。</p>
<p>​    对于LocalDate类，请不要使用其构造器来构造LocalDate类对象，实际上，应当使用静态 <strong>工厂方法</strong> ，它会代表你调用构造器，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate Test = LocalDate.now();</span><br></pre></td></tr></table></figure>

<p>​    这个表达式会构造一个新对象，表示构造这个对象时的日期，当然，可以提供年、月、日来构造一个对应特定日期的对象，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate Test = LocalDate.of(<span class="number">1999</span>,<span class="number">12</span>,<span class="number">31</span>);</span><br></pre></td></tr></table></figure>

<p>​    此时Test指向的LocalDate对象便是一个特定的时间对象（1999年12月31日），另外，一旦拥有了一个LocalDate对象，可以使用getYear，getMonthValue，getDayOfMonth得到年，月，日：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Year = Test.getYear(); <span class="comment">//1999</span></span><br><span class="line"><span class="keyword">int</span> Month = Test.getMonthValue(); <span class="comment">//12</span></span><br><span class="line"><span class="keyword">int</span> Day = Test.getDayOfMonth(); <span class="comment">//31</span></span><br></pre></td></tr></table></figure>

<p>​    这看起来似乎没有多大的意义，毕竟这获得的值都是构造对象时所使用的那些值，不过，有时可能有一个计算得到的日期，然后你希望调用这些方法来了解它的更多信息。</p>
<p>​    例如，plusDays方法会得到一个新的LocalDate类对象，如果应用这个方法得到的对象称为当前对象，这个新日期对象则是距当前对象指定天数的一个新日期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate aLaterTest = Test.plusDay(<span class="number">1000</span>);</span><br><span class="line">year = aLaterTest.getYear(); <span class="comment">//2002</span></span><br><span class="line">month = aLaterTest.getMonthValue(); <span class="comment">//09</span></span><br><span class="line">Day = aLaterTest.getDayOfMonth(); <span class="comment">//26</span></span><br></pre></td></tr></table></figure>

<p>​    LocalDate类封装了实例来维护所设置的日期。如果不查看源代码，就不可能知道类内部的日期表示。当然，封装的意义就在于内部表示不重要，重要的是类对外提供的方法。</p>
<p>​    实际上，Date类也有得到日，月，年的方法，分别是getDay，getMonth，getYear，不过这些方法<strong>已经废弃</strong>。当类库的设计者意识到某个方法最初就不该引入时，就会把它标记为废弃，不再鼓励他人使用。</p>
<p>​    类库的设计者意识到应当单独提供类来处理日历，不过在此之前这些方法已经是Date类的一部分了。Java1.1中引入较早的一组日历类时，Date方法被标记为废弃不用。虽然现在仍然可以使用这些方法，但编译器在编译时会对此提出警告，最好还是不要使用这些废弃的方法，因为将来的某个类库版本很有可能会将这些方法完全删除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/14/SWing%E2%80%94%E2%80%94Java%E5%A6%82%E4%BD%95%E7%94%BB%E5%87%BA%E6%96%B9%E6%A0%BC%E7%BA%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/14/SWing%E2%80%94%E2%80%94Java%E5%A6%82%E4%BD%95%E7%94%BB%E5%87%BA%E6%96%B9%E6%A0%BC%E7%BA%B8/" class="post-title-link" itemprop="url">Swing - 如何画出方格纸</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-14 15:38:53" itemprop="dateCreated datePublished" datetime="2021-07-14T15:38:53+08:00">2021-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-20 11:16:18" itemprop="dateModified" datetime="2021-07-20T11:16:18+08:00">2021-07-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如何画出方格纸？</p>
<h2 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h2><p>先上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gr</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个方格的宽度和长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Root_Width = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Root_High = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 界面的方格的行数和列数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Width = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> High = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gr gr = <span class="keyword">new</span> Gr();</span><br><span class="line">        gr.Run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setTitle(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.setSize(Root_Width * Width , Root_High * High);</span><br><span class="line">        <span class="keyword">this</span>.setLocation(<span class="number">300</span>,<span class="number">400</span>);</span><br><span class="line">        <span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setResizable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        Color c = g.getColor();</span><br><span class="line">        g.setColor(Color.GRAY);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 将界面画成 Width * High的方格组成，使用两个for循环</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Width; i++)</span><br><span class="line">            g.drawLine(<span class="number">0</span>, i * Root_High, Root_Width * Width, i * Root_High);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++)</span><br><span class="line">            g.drawLine(i * Root_Width, <span class="number">0</span>, i * Root_Width, High * Root_High);</span><br><span class="line"></span><br><span class="line">        g.setColor(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码拆解"><a href="#代码拆解" class="headerlink" title="代码拆解"></a>代码拆解</h2><h4 id="第一部分-完成一个界面"><a href="#第一部分-完成一个界面" class="headerlink" title="第一部分 完成一个界面"></a>第一部分 完成一个界面</h4><p>创建一个类Gr，这个类继承于 JFrame类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Gr extends JFrame &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在类中，定义了四个常量，分别是每个方格的宽度和长度 以及 界面的方格行数和列数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一个方格的宽度和长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Root_Width = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Root_High = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 界面的方格的行数和列数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Width = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> High = <span class="number">40</span>;</span><br></pre></td></tr></table></figure>

<p>在类中，定义一个无参函数Run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置标题</span></span><br><span class="line">    <span class="keyword">this</span>.setTitle(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    <span class="comment">//设置控件的宽度 和 长度</span></span><br><span class="line">    <span class="keyword">this</span>.setSize(Root_Width * Width , Root_High * High);</span><br><span class="line">    <span class="comment">//设置控件的位置，参数是左上角的坐标</span></span><br><span class="line">    <span class="keyword">this</span>.setLocation(<span class="number">300</span>,<span class="number">400</span>);</span><br><span class="line">    <span class="comment">//这个是表示在窗口添加一个Windows消息事件，其目的是我们关闭窗口的时候可以正常退出，其实等价于 frame.setDefaultCloseOptration(JFrame.EXIT_ON_CLOSE);</span></span><br><span class="line">    <span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置此窗体是否允许用户调整大小</span></span><br><span class="line">    <span class="keyword">this</span>.setResizable(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//设置是否允许JVM可以执行paint方法执行画图，安全起见，一般将其放在程序的最后</span></span><br><span class="line">    <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数中，从上至下完成对界面的设置，完成对界面的构造</p>
<h4 id="第二部分-将界面画成网格线"><a href="#第二部分-将界面画成网格线" class="headerlink" title="第二部分 将界面画成网格线"></a>第二部分 将界面画成网格线</h4><p>对此需要在类中重写paint方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">    Color c = g.getColor();</span><br><span class="line">    <span class="comment">//设置网格中线的颜色</span></span><br><span class="line">    g.setColor(Color.GRAY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将界面画成 Width * High的方格组成，使用两个for循环</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Width; i++)</span><br><span class="line">        g.drawLine(<span class="number">0</span>, i * Root_High, Root_Width * Width, i * Root_High);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++)</span><br><span class="line">        g.drawLine(i * Root_Width, <span class="number">0</span>, i * Root_Width, High * Root_High);</span><br><span class="line"></span><br><span class="line">    g.setColor(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上方的代码中，使用了两个for循环来完成对网格的绘画</p>
<p>基本思想是，使用Graphics类的drawLine函数来完成，函数将画一条 A 到 B 的直线。</p>
<p>函数的参数为 A 点的 x坐标，A 点的 y坐标，B 点的 x坐标，B 点的 y坐标</p>
<p>在完成上面两部分后，网格就完成了，效果如图：</p>
<p><img src="/2021/07/14/SWing%E2%80%94%E2%80%94Java%E5%A6%82%E4%BD%95%E7%94%BB%E5%87%BA%E6%96%B9%E6%A0%BC%E7%BA%B8/Users\Arsh\Blog\source_posts\SWing-之-Java如何画出方格纸.png" alt="捕获"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">学习笔记——面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-12 19:26:54" itemprop="dateCreated datePublished" datetime="2021-07-12T19:26:54+08:00">2021-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-05 19:53:00" itemprop="dateModified" datetime="2021-12-05T19:53:00+08:00">2021-12-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    基础大致有 概述，用户自定义类，静态字段 和 静态方法，对象的构造，包，注释 7个部分</p>
<p>​    参考 Java核心技术卷一  第四章</p>
<h2 id="屁话"><a href="#屁话" class="headerlink" title="屁话"></a>屁话</h2><p>​        将Java核心技术卷一第四章关于面向对象的内容重读后总结的一些想法。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        面向对象的程序都是由对象组成的，每个对象包含对用户公开的特定功能和隐藏的实现功能</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>​        类 是构造对象的模板或蓝图，由类构造对象的过程称为创建类的实例</p>
<p>​        封装（有时也称呼为 数据隐藏）是处理对象的一个重要概念。从形式上看，封装就是将数据和行为组合到一个包中，并对对象的使用者隐藏具体的实现方式</p>
<p>​        实现封装的关键在于 绝对不能让类中的方法直接访问其他类的实例字段</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>​        我们可以考虑到对象的三个主要特性：行为，状态和标识</p>
<p>​            行为：对象可以完成的操作 或者 对象可以执行的方法</p>
<p>​            状态：调用了方法时，对象做出的响应</p>
<p>​            标识： 区分具有相同行为与状态的不同对象</p>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><p>​        最常见的关系为 依赖，聚合 和 继承</p>
<p>​            依赖：是一种最常见，明显的关系。两个类的耦合程度高，缺一不可</p>
<p>​            聚合：A类的对象 包含 B类的对象</p>
<p>​            继承：表示一个更特殊的类 与 一个更一般的类之间的关系，以后再说</p>
<h4 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h4><p>​        要想使用对象，必须先构造对象，指定其初始状态</p>
<p>​        比如构造一个Date类的对象，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date aDate = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure>

<p>​        但在Java中，任何对象变量的值都是存储在另一个地方的某个对象的引用</p>
<p>​        在上方的表达中 new Date() 构造了一个Date类型的对象，他的值式对新创建对象的一个引用，而这个变量储存在 aDate 中，当然，在创建对象时，也可以直接将这个对象变量设置为 null，即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date aDate = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>​         指示这个对象变量aDate目前没有引用任何对象</p>
<h4 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h4><p>​         首先引入一段方法调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate aTest = newYearsEve.plusDays(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>​         在这个调用中newYearsEve.plusDays(int A); 会将aTest的时间改为 A 的数值</p>
<p>​         事实上，plusDay方法并没有将aTest的值直接修改为1000，而是先生成一个LocalDate对象（和aTest同类的对象），值为1000，再把这个新对象赋给aTest，原本aTest指向的对象并没有改动</p>
<p>​         因此，对于这种没有改变原本对象的方法就是访问器方法</p>
<p>​         相对的，对原本对象进行改变的就是更改器方法</p>
<h2 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h2><h4 id="最简单的定义类"><a href="#最简单的定义类" class="headerlink" title="最简单的定义类"></a>最简单的定义类</h4><p>​         先从一个简单的构造类开始说起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Exercise.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Employee employee = <span class="keyword">new</span> Employee(); <span class="comment">// 创建一个Employee类的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// Employee类的String类型属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary; <span class="comment">// Employee类的double类型属性</span></span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay; <span class="comment">// Employee类的LocalDate类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Employee的构造函数，调用此函数来构造一个Employee的对象，并对其进行初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">        salary = s;</span><br><span class="line">        hireDay = LocalDate.of(year,month,day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Employee的三个用来获取Employee对象属性值的函数</span></span><br><span class="line">    <span class="comment">// 因为Employee的属性值因为信息隐藏原则皆设定为private，所以需要外部函数获取</span></span><br><span class="line">    <span class="comment">// getSalary(),getHireDay(),getName()分别获取salary,hireDay,name 的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Employee类用来对对象的salary值进行修改的函数（ 增加参数的值 ）</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        salary = salary + raise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        上方的代码就是一个十分简单的自定义类，接下来，对Employee类进行剖析</p>
<h4 id="剖析自定义类"><a href="#剖析自定义类" class="headerlink" title="剖析自定义类"></a>剖析自定义类</h4><p>​        通过代码可知，这个类包含一个 构造器 和 4个方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span></span><br></pre></td></tr></table></figure>

<p>​        可以看出，这个类的所有方法都被标记为public，关键字public意味着任何方法都可以随意调用这些方法</p>
<p>​        另外，在这个类的实例中有三个实例字段用来存放将要操作的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name; <span class="comment">// Employee类的String类型属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> salary; <span class="comment">// Employee类的double类型属性</span></span><br><span class="line"><span class="keyword">private</span> LocalDate hireDay; <span class="comment">// Employee类的LocalDate类型</span></span><br></pre></td></tr></table></figure>

<p>​        关键字private确保只有Employee类自身的方法能够访问这些实例字段，而其他类的方法不能读写这些字段</p>
<h4 id="刨析构造器"><a href="#刨析构造器" class="headerlink" title="刨析构造器"></a>刨析构造器</h4><p>​        先来看看这个类的构造器方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">       name = n;</span><br><span class="line">       salary = s;</span><br><span class="line">       hireDay = LocalDate.of(year,month,day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以看到，构造器和类同名，在构造某个类的对象时，构造器便会运行，从而将实例字段初始化为希望的初始状态</p>
<p>​        例如，现在构造一个Employee类的实例对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee test = <span class="keyword">new</span> Employee(<span class="string">&quot;James Bond&quot;</span>,<span class="number">10000</span>,<span class="number">1950</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​        便会调用构造器方法并生成一个Employee类的对象，其中的实例字段会被设置为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;James Bond&quot;</span>;</span><br><span class="line">salary = <span class="number">10000</span>;</span><br><span class="line">hireDay = LocalDate.of(<span class="number">1950.1</span><span class="number">.1</span>);</span><br></pre></td></tr></table></figure>

<p>​        另外，构造器方法总是和new运算符一起使用，不能对一个几经存在的对象调用构造器来达到重新设置实例字段的目的</p>
<p>​    </p>
<p>​        现在可以总结构造器的特定：</p>
<ol>
<li>构造器与类同名</li>
<li>每个类可以有多个构造器</li>
<li>构造器可以有多个参数 当然也可以没有参数</li>
<li>构造器没有返回值</li>
<li>构造器总是配合new运算符一起调用的</li>
</ol>
<h4 id="使用-var-声明局部变量"><a href="#使用-var-声明局部变量" class="headerlink" title="使用 var 声明局部变量"></a>使用 var 声明局部变量</h4><p>​        在Java10以后，如果可以从变量的初始值推断出它们的类型，那么便可以使用var关键字进行声明局部变量，而无需指定类型。还是以上方的Employee类为例，原本声明一个Employee类的对象需要下列语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee test = <span class="keyword">new</span> Employee(<span class="string">&quot;Harry Hacker&quot;</span>,<span class="number">50000</span>,<span class="number">1989</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​        现在可以利用var关键字经行如下声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = new Employee(&quot;Harry Hacker&quot;,50000,1989,10,1);</span><br></pre></td></tr></table></figure>

<p>​        这是一个有效避免重复书写类名的方法，但需要注意的是，**var关键字只能用于方法中的局部变量 **，参数和字段的类型必须声明</p>
<h4 id="使用-null-引用"><a href="#使用-null-引用" class="headerlink" title="使用 null 引用"></a>使用 null 引用</h4><p>​        在前面我们了解到，一个对象变量包含一个对象的引用，或者包含一个特殊值null，后者表示没有引用任何对象</p>
<p>​        null值不可应用于方法，如果对null值应用于一个方法，那么将产生一个 NullPointerException 异常，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate birthday = <span class="keyword">null</span>;</span><br><span class="line">String s = birthday.toString(); <span class="comment">// 此处编译时，编译器会抛出一个NullPointerException 异常</span></span><br></pre></td></tr></table></figure>

<p>​        对于Java而言，这是一个相当严重的错误，类似于 “索引越界” 异常。如果你的程序没有捕获这个异常，那么程序将直接终止</p>
<p>​        正常情况下，程序并不会去主动捕获这些异常，而是依赖于程序员从一开始就不要这么做。因此，在定义一个类时，程序员需要知道这个类中有哪些部分可以使用null，哪些不能使用null</p>
<p>​        说实话，在构造类时，应该询问自己：是否真的希望某个值为null值，如果不是，就应该严令这个参数拒绝null值</p>
<p>​        在Java9以后，Object类提供一种可以在构造函数时就拒绝null值的方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String n, <span class="keyword">double</span> s, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">	Object.requireNonNull(n,<span class="string">&quot;The name cannot be null&quot;</span>);</span><br><span class="line">	name = n;</span><br><span class="line">	........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在上方的例子中，如果有人在调用Employee类构造函数时传入一个null值，就会产生一个NullPointerException 异常。</p>
<h4 id="显示参数-和-隐式参数"><a href="#显示参数-和-隐式参数" class="headerlink" title="显示参数 和 隐式参数"></a>显示参数 和 隐式参数</h4><p>​        参数是方法用于操作对象以及存取它们的实例字段。例如下面一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> raise = salary * byPercent / <span class="number">100</span>;</span><br><span class="line">	salary = salary + raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        对于这个方法，其中有两个参数。第一个参数称为隐式( implicit )参数，是出现在方法名前的Employee类型的对象。第二个参数是位于方法名后面括号中的数值，这是一个显示( explicit )参数。</p>
<p>​        可以看到，显示参数明显的列在方法声明中，例如上例方法中的 double byPercent 。隐式参数没有出现在方法声明中</p>
<p>​        在每一个方法中，关键字 this 指示隐式函数。如果喜欢的话，可以将上方的例子函数改写为下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> raise = <span class="keyword">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">this</span>.salary = <span class="keyword">this</span>.salary + raise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        有不少的人偏爱于这种书写风格，因为这样可以将实例字段和局部变量分隔开</p>
<h4 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h4><p>​        在讲述封装的优点之前，先给出几个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> hireDay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这些都是典型的访问器方法，由于这些方法只可以返回实例字段值，因此又被称呼为 <strong>字段访问器</strong></p>
<p>​        当然，如果从便捷的方向考虑，将这些实例字段设置为公开的。但此时就有了一个问题，如果将这些实例字段设置为公开的，那么这些字段就会无时无刻面临着被破坏的风险，而且这些发现来自于任何地方，这非常不利于对程序的调试</p>
<p>​        那么封装的好处就显而易见了，封装可以有效避免字段被破坏，一般而言，封装会使很多实例字段在第一次赋值后就不再改变，除非程序员额外提供用于修改这个实例字段的方法</p>
<p>​        既然了解了封装的必要，那么有的时候，我们需要得到或修改，设置某个实例字段的值，程序设计者就需要提供以下三项内容：</p>
<ol>
<li>​    一个私有的数据字段</li>
<li>​    一个公共的字段访问器方法</li>
<li>​    一个公共的字段修改器方法</li>
</ol>
<p>​        这样会为我们带来不少好处，首先，可以在改变内部实现时不影响其他的代码，其次，更改器方法可以完成错误检查，而对直接对字段赋值就无法做到</p>
<h4 id="基于类的访问权限"><a href="#基于类的访问权限" class="headerlink" title="基于类的访问权限"></a>基于类的访问权限</h4><p>​        从前面我们已经知道，方法可以调用这个类中的私有数据。一个方法可以方法问所属类的所有对象的私有数据，这不奇怪吗！例如，下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">	............ <span class="comment">// 这里省略了Employee类的构造函数和一些实例字段的设定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Employee other)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name.equals(other.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        典型的调用方法是： if ( harry.equals(boos) )… </p>
<p>​        这个方法访问了harry了这个对象的私有字段，这点并不奇怪，但同时，这个还方法还访问了boos的私有字段。当然，这是合法的，其原因是harry和boos都是Employee类对象，而Employee类的方法可以访问任何Employee类对象的私有字段</p>
<h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>​        在实现一个类时，由于公共数据十分危险，所以应该将所有的数据字段都设置为私有。然而，方法又该如何设计呢？</p>
<p>​        尽管在大多时候，方法都是公开的。但在有些时候，将一个方法设置为私有的可能会很有用。有时，你可能希望将一个计算机代码分解为若干个独立的辅助方法。通常，这些辅助方法不应该成为公共接口的一部分，因为他们与当前代码的关系十分紧密，或者这些辅助方法需要一个特殊协议，或者需要特别的调用次序。若这些方法公开，将会造成不小的麻烦，因此建议将其设置为私有方法</p>
<p>​        在Java中，要实现私有方法，只需要将关键字从public改为private即可</p>
<p>​        通过将方法设置为私有，如果你改变了方法的实现方式，将没有义务保证这个方法依然可用。如果数据的表示发生了变化，这个方法肯会变得难以实现，或者变得不再被需要；这并不重要，重点在于，只要方法是私有的，类的设计者就可以确认这个方法在这个类以外的地方不会被使用，所以在需要时可以将其删去。如果一个方法时公开的，那么就不能轻易的将其删除，毕竟有可能有其他的方法依赖于这个方法。</p>
<h4 id="final实例字段"><a href="#final实例字段" class="headerlink" title="final实例字段"></a>final实例字段</h4><p>​        可以将实例字段定义为final，这样的字段必须在构造时就初始化。也就是说，必须确保在每一个构造器执行之后，这个字段的值已经设置，并且以后不能再修改这个字段。</p>
<p>​        final修饰符对于类型为 基本类型 或者 不可变类 的字段尤其有用。（ 如果类中的所有方法都不会改变其对象，这样的类就是不可变的类。例如，String类就是不可变的类 ）</p>
<p>​        那么，对于大部分可变的类，随意使用final就有可能会造成混乱。</p>
<h2 id="静态字段-和-静态方法"><a href="#静态字段-和-静态方法" class="headerlink" title="静态字段 和 静态方法"></a>静态字段 和 静态方法</h2><p>​        在前面给出的实例程序中，有许多位置使用了static修饰符（main方法），下面来讨论这个修饰符的含义。</p>
<h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>​        如果将一个字段定义为static，每个类只有一个这样的字段。而对于非静态的实例字段，每个对象都有一个自己的副本。下面用一个简单的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在上面的Employee类中，我们定义了两个属性，id 和 静态字段nextId。现在构造许多个Employee类的对象，每个对象都有一个属于自己的属性id，且互相不干涉，但是所有Employee类的对象都共用一个静态字段nextId。由此可以得出结论：静态字段只属于类，而不属于对象。</p>
<p>​        基于这个特点，在静态字段在被定义时，就已经被构造，存在于内存中。</p>
<h4 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h4><p>​        在Java中，静态变量使用的比较少，更多的时候会使用静态常量。例如，在类中定义一个静态常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在上面的实例中，我们在Test类中定义了一个静态常量PI，在以后调用时，调用PI就等于使用3.1415926的值。当然静态常量和静态字段都有着相同的属性，她们只属于类而不属于对象，在被定义时就已经被构造。</p>
<p>​        在此之外，静态常量是可以被定义为public的，因为静态常量在定义是使用了final，无法被修改。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>​        静态方法是不再对象上执行的方法，例如，在Math类中的pow方法就是一个静态方法。使用方法也十分直接，以pow方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(x,a)</span><br></pre></td></tr></table></figure>

<p>​        在上面的例子中，函数会计算x的a次幂。在完成幂运算时，这个函数并没有使用任何Math对象，换句话说，静态方法在运行的过程中并没有调用任何函数。</p>
<p>​        对于静态方法还有一些其他的特殊点，对于静态方法而言，静态方法只能调用类的静态常量，无法访问对象的实例字段，毕竟她在运行过程中不会借用任何对象。</p>
<p>​        在下面两种情况下，可以使用静态方法：</p>
<pre><code> 1.    方法不需要访问对象状态，因为她需要的所有参数都通过显示参数提供（例如: Math.pow）。
 2.    方法只需要访问类的静态字段（ 例如: Employee.getNextId ）。
</code></pre>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>​        在Java中的静态方法还有一种常用的用途，使用类似 LocalDate 和 NumberFormat 的类使用静态工厂方法来量产不同的实例对象。以NumberFormat 类举例就有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 NumberFormat 类的不同对象</span></span><br><span class="line">NumberFormat currencyFormat = NumberFormat.getCurrencyInstance();</span><br><span class="line">NUmberFormat percentFormat = NumberFormat.getPercentInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">System.out.println( currencyFormat.format(x) ); <span class="comment">// 打印结果 ：$0.10</span></span><br><span class="line">System.out.println( percentFormat.format(x) ); <span class="comment">// 打印结果 ：10%</span></span><br></pre></td></tr></table></figure>

<p>​        当然，首当其冲有一个问题，为什么不使用new关键字来构造对象？ 这主要是两个原因：</p>
<p>​        1.    无法命名构造器。构造器的名字必须和类名相同，而就如上方的例子中所表现的。但是，这里希望获取两种不同表示方法的数字输出方法，分别得到货币实例和百分比实例。</p>
<p>​        2.    使用构造器时，无法改变所构造对象的类型，而实际上，工厂方法返回的对象是 NumberFormat 的一个子类。</p>
<h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>​        需要注意的是，可以调用静态方法而不需要任何对象，例如，不需要构造Math类的任何对象就可以调用Math.pow函数。</p>
<p>​        同理，main方法也是一个静态方法。main方法不对任何对象进行操作，事实上，在启动程序时还没有任何对象。静态的main方法将执行并构造程序所需要的对象。</p>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p>​        那么既然讲方法参数，就需要先把Java对于传入方法参数的流程拉出来讲一讲。首先，就需要搞几个专业术语来说说。</p>
<h4 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h4><p>​        <strong>按值调用</strong> ：表示方法接受的是调用者提供的值。</p>
<p>​        <strong>引用调用</strong> ：表示方法接受的是调用者提供的变量地址。</p>
<p>​        对于上面两种方法，方法可以修改 <strong>引用调用</strong> 的变量的值而不能修改 <strong>按值调用</strong> 传递的变量的值。</p>
<h4 id="Java传递方法参数的一般机制"><a href="#Java传递方法参数的一般机制" class="headerlink" title="Java传递方法参数的一般机制"></a>Java传递方法参数的一般机制</h4><p>​        对于Java，Java程序设计语言总是 <strong>按值调用</strong> ，也就是说，方法得到的是所有参数值的一个副本，具体来讲，方法不能修改传递给她的任何参数变量的内容。下面，举一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">harry.raiseSalary( percent );</span><br></pre></td></tr></table></figure>

<p>​        无论这个叫 raiseSalary 的方法如何具体实现，我们知道，在这个方法调用之后，percent 这个变量的值依然是 10。</p>
<p>​        那么，为了使得 <strong>Java的方法无法修改所传入的变量的值</strong> 这个特性变得更加具体，好理解，那么我们举一个更具体的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">( <span class="keyword">double</span> x )</span></span>&#123;</span><br><span class="line">	x = x * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> percent = <span class="number">10</span>;</span><br><span class="line">raiseSalary( percent );</span><br></pre></td></tr></table></figure>

<p>​        在上面的例子里面，我们将 raiseSalary 方法进行了实现，这个方法希望将传入的参数增加三倍。好吧，在运行结束以后，这个方法失败了，传入的变量 percent 的值依旧是 10 。说到底，方法可以改变的是从传入的变量那里获取的副本，这自然无法影响到其本身。</p>
<p>​        为了在直观一点，我们来拆解一下她的运行顺序：</p>
<p>​        1.    x 值初始化为 percent 值的一个副本</p>
<p>​        2.    x 乘以 3 后等于 30，但是 percent 的值依旧是 10</p>
<p>​        3.    这个方法运行结束之后，参数变量 x 便不再被使用</p>
<p>​        然而，有两种类型的方法参数： 基本数据类型（int、double等基本类型） 和 对象引用（实例化自定义类的对象）。</p>
<p>​        我们已经看到了，方法无法修改基本类型的参数的值，而当传入方法参数是对象引用时，情况就将发生变化了。下面举一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void tripleSalary(Employee x)&#123;</span><br><span class="line">	x.raiseSalary( 200 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">harry = new Employee(...); // 此处省略Employee类的定义</span><br><span class="line">tripleSaraly( harry );</span><br></pre></td></tr></table></figure>

<p>​        当我们执行了上方的代码后，harry 对应的对象的值成功的翻了三倍，Oh，真是不可思议。理由也很简单，因为在函数中改变对象时，实际改变的是传入参数的值的副本。但对于 对象引用 时，参数的值的副本 和 参数本身 都只是指向对象的一个引用。改变参数值的副本，也就是改变了参数本身。因此，实现一个改变对象参数状态的方法是完全可行的。</p>
<p>​        那么，我们总结一下Java中对方法参数能做什么 和 不能做什么：</p>
<p>​        1. 方法不能修改基本数据类型的参数（即数值型 或者 布尔型）。</p>
<p>​        2. 方法可以改变对象参数的状态。</p>
<p>​        3. 方法不能让一个对象参数引用一个新的对象。</p>
<h2 id="对象的构造"><a href="#对象的构造" class="headerlink" title="对象的构造"></a>对象的构造</h2><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>​        有些类拥有多个构造器。例如，你可以构造一个空的 StringBuilder 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> messages = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>

<p>​        也可以指定构造一个初始字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> messages = <span class="keyword">new</span> StringBuilder( <span class="string">&quot;To do&quot;</span> );</span><br></pre></td></tr></table></figure>

<p>​        这种功能就是重载( Overloading )。如果多个方法有相同的名字、不同的参数，便出现了重载。编译器必须挑选出具体调用哪个方法。在使用重载时，编译器会通过传入的参数来进行匹配，来选择调用正确的构造方法。</p>
<p>​        如果编译器找不到相匹配的参数，那么就会产生编译错误，因为根本不存在匹配，或者没有一个比其他的更好( 这个查找匹配的过程被称之为 <strong>重载解析</strong> )。</p>
<p>​        另外，Java 允许重载任何方法，而不只是构造方法。因此，在使用一个函数时，需要完整的描述指定的 方法名 以及 参数类型 ，这叫做方法的 <strong>签名</strong> 。例如，String 类有 4 个名为 indexOf 的公共方法，她们的签名是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">indexOf( <span class="keyword">int</span> );</span><br><span class="line">indexOf( <span class="keyword">int</span>, <span class="keyword">int</span> );</span><br><span class="line">indexOf( String );</span><br><span class="line">indexOf( String, <span class="keyword">int</span> );</span><br></pre></td></tr></table></figure>



<h4 id="默认字段初始化"><a href="#默认字段初始化" class="headerlink" title="默认字段初始化"></a>默认字段初始化</h4><p>​        如果在构造器中并没有显示的为字段设置初值，那么就会被自动的被赋予默认值： 数值为 0、布尔值为 false、 对象引用为 null。有些人认为依赖默认值是一种不好的行为，的确，如果不明确的对字段进行初始化，就会影响程序代码的可读性。</p>
<p>​        在这里，要指出一个 字段 和 局部变量 的一个重要区别。方法中的局部变量必须要明确的初始化，但是在类中，如果没有初始化类中的字段，将会自动初始化为默认值( 0 、 false、 null )。</p>
<p>​        举个例子，以上方讨论过的 Employee 类为例子。假定没有在构造器中指定如何初始化某些字段，默认状态下，就会将 salary 字段初始化为 0 , 将 name 和 hireDay 字段初始化为 null 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// Employee类的String类型属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary; <span class="comment">// Employee类的double类型属性</span></span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay; <span class="comment">// Employee类的LocalDate类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        但是，这显然不是一个好主意。因为此时如果我们调用 getName 方法 或者 getHireday 方法，就会得到一个 null 引用，这应该不是我们所希望的结果。</p>
<p>​        如果此时我们调用方法，就会发生下面的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee harry = <span class="keyword">new</span> Employee();</span><br><span class="line">LocalDate h = harry.getHireDay();</span><br><span class="line"><span class="keyword">int</span> year = h.getYear(); <span class="comment">// throws exception if h is null</span></span><br></pre></td></tr></table></figure>



<h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><p>​        很多类都包含一个无参数的构造器，由无参数构造器创建对象时，对象的状态会设置为适当的默认值。</p>
<p>​        例如，以下是 Employee 类的无参数构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;</span><br><span class="line">	name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	salary = <span class="number">0</span>;</span><br><span class="line">	hireDay = LocalDate.now();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果在定义一个类时并没有书写构造器，编译器会自动提供一个构造器。这个构造器将 <strong>所有的</strong> 实例字段设置为默认值。于是，就和在方法参数部分中写道的相同，实例字段中的数值型数据设置为 0，布尔型数据设置为 false， 所有对象变量将设置为 null。</p>
<p>​        如果类中提供了至少一个构造器，但是没有提供无参的构造函数，那么在构造对象时如果不提供参数就是不合法的。</p>
<p>​        要记住的是，仅仅只有当类中没有任何构造器时，编译器才会提供一个默认的无参构造器。</p>
<h4 id="显示字段初始化"><a href="#显示字段初始化" class="headerlink" title="显示字段初始化"></a>显示字段初始化</h4><p>​        通过重载类的构造器方法，可以采用多种形式设置类的实例字段的初始状态。不管如何调用构造器，每个实例字段都要设置一个<strong>有意义的初始值</strong>，确保这一点总是一个不错的好主意。</p>
<p>​        在执行构造器之前完成这个赋值操作，如果一个类的所有构造器都希望把某个特定的实例字段都设定为一个值，那么这个语法就特别有用。当然，初始值并不一定是常量值，比如下面的例子，就是利用方法调用初始化一个字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextInd;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id = assignId();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> assignId&#123;</span><br><span class="line">		<span class="keyword">int</span> r = nextId;</span><br><span class="line">		nextId = nextId + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="参数名"><a href="#参数名" class="headerlink" title="参数名"></a>参数名</h4><p>​        在编写一些规模较小的构造器时，常常在参数命名时感到困惑，毕竟起名字是一个比较困难的问题。</p>
<p>​        通常喜欢使用单个字母来作为参数名，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">( String n, <span class="keyword">double</span> s )</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = n;</span><br><span class="line">	<span class="keyword">this</span>.salary = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        这样做的好处就是十分清晰，后来的维护者可以一眼就看懂参数的含义。另外还有一种常用的技巧，这种技巧基于一个Java的机制：<strong>参数变量会遮蔽同名的实例字段</strong>。例如，如果将参数名命名为salary，salary将指示这个参数，而不是实例字段。但是还是可以使用this关键字来访问实例字段。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">( String name, <span class="keyword">double</span> salary )</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="调用其他的构造器"><a href="#调用其他的构造器" class="headerlink" title="调用其他的构造器"></a>调用其他的构造器</h4><p>​        关键字this指示一个方法的隐式参数。不过，这个关键字还有另外一个含义。</p>
<p>​        如果构造器的第一个语句形如this( … )，这个构造器将调用同一个类的另一个构造器。下面提供一个典型的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">( <span class="keyword">double</span> s )</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>( <span class="string">&quot; Employee # &quot;</span> + nextId, s );</span><br><span class="line">	nextId = nextId + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        当调用 new Employee( 6000 ) 时， Employee( double ) 构造器将调用 Employee( String, double ) 构造器。当采用这种方式时，this关键字就变得十分有用，这样</p>
<h4 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h4><p>​        前面已经讲过两种初始化数据字段的方法：在构造器中设置值 和 在声明中赋值</p>
<p>​        实际上，Java还有第三种机制，称之为初始化块( initialization block )。在一个类中的声明中，可以包含多任意多个代码块。只要构造这个类，这些块就会被执行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		id = nextId;</span><br><span class="line">		nextId = nextId + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">( String n, <span class="keyword">double</span> s )</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		salary = s;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(  )</span></span>&#123;</span><br><span class="line">		name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		salary = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在上面的示例中，无论使用哪种构造器进行构造对象，id 字段都会在对象初始化块中初始化。首先运行初始化块，然后才运行构造器的主体部分。</p>
<p>​        当然，这种不是必须的，同时这种程序也不常见。通常会直接将初始化代码放在构造器中。要注意的是，虽然可以在初始化块中设置字段，即使这些字段在类后面才定义，这是合法的行为。但是一般为了避免重复定义，不允许读取在后面初始化的字段。</p>
<p>​        由于Java拥有多种初始化数据字段的途径，所以列出构造过程的所有路径可能让人十分困惑。下面是调用构造器的具体处理步骤：</p>
<p>​        1、 如果构造器的第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器。</p>
<p>​        2、 否则，</p>
<p>​                a) 所有数据字段初始化为其默认值( 0、false 或者 null )。</p>
<p>​                b) 按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块。</p>
<p>​        3、 执行构造器主体代码。</p>
<p>​        当然，应该精心组织好初始代码块，可以使用静态的初始化块。</p>
<p>​        将代码放入一个块中，并且在上方标记为 static 。下面提供一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">var</span> genertor = <span class="keyword">new</span> Random();</span><br><span class="line">	nextId = genertor.nextInt( <span class="number">1000000</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上方代码的功能：为员工Id随机生成一个小于 1000000 的随机数。</span></span><br></pre></td></tr></table></figure>

<p>​        在类第一次加载的时候，将会进行静态字段的初始化。和实例字段一样，除非将静态字段显示地设置成其他值，否则默认的初始值都是0、false 或 null。所有的静态字段初始化方法以及静态初始化块都将依照类声明中出现的顺序执行。</p>
<h4 id="对象析构-和-finalize方法"><a href="#对象析构-和-finalize方法" class="headerlink" title="对象析构 和 finalize方法"></a>对象析构 和 finalize方法</h4><p>​        有些面向对象的程序设计语言，特别是 C++ ，有显示的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码。在析构器中，最常见的操作是回收分配给对象的储存空间。</p>
<p>​        而由于 Java 存在自我回收垃圾的机制，不需要人工回收内存，所以 Java 不支持析构器。</p>
<p>​        当然，某些对象使用了内存之外的资源时情况就会发生一些变化。比如，文件可能使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用显得十分重要</p>
<p>​        如果一个资源一旦使用完后就需要立刻关闭，那么应该提供一个 close 方法来完成必要的清理工作。可以在对象使用完成时调用这个方法。在往后 <em>异常、断言和日志</em> 中会介绍如何确保自动调用这个方法。</p>
<p>​        如果可以等到Java虚拟机自动退出，那么可以用方法 <strong>Runtime.addShutdownHook</strong> 增加一个 ”关闭钩“ 。在 Java9 中，可以使用 Cleaner 类注册一个动作，当对象不再可达时( 除了清洁器还可以访问，其他对象都无法访问这个对象 )，就会完成这个动作。在世界中这些情况十分少见。</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>​        Java允许使用包 package 将类组织在一个集合中。借助包可以方便的组织自己的代码，并将自己的代码与别人提供的代码库分开管理。下面将介绍如何使用和创建包。</p>
<h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><p>​        使用包的主要原因是确保类名的唯一性，在同一包内绝不能出现两个相同名字的类。假如两个程序员不约而同的创建了Employee类，只要将这些类放在不同的包中，就不会产生冲突。</p>
<p>​        事实上，为了保证包名的绝对唯一性，要用一个因特网域名 ( 这显然是唯一的 ) 以逆序的形式来作为包名，然后对于不同的工程使用不同的子包。</p>
<p>​        例如，考虑域名 horstann.com。如果以逆序来写，就得到了包名 com.horstann 。</p>
<p>​        然后为了更进一步的确保唯一性，可以在后面追加工程名，如 com.horstann.coreJava 。如果再把 Employee 类放在这个包里，那么这个类的 “ 完全限定 ” 名就是 com.horstann.coreJava.Employee 。</p>
<h4 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h4><p>​        一个类可以使用所属包中的所有类，以及其他包中的公共类( public class )。我们可以采用两种方式访问另一个包中的公共类。</p>
<p>​        第一种方法就是使用 <strong>完全限定名( fully qualified name )</strong> ，也就是包名后面跟着类名。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.time.LocalDate today = java.time.LocalDate.now();</span><br></pre></td></tr></table></figure>

<p>​        这显然十分繁琐。更简单也更常见的方法是使用 <strong>import</strong> 语句。<strong>import</strong> 语句是一种引用包中个类的简洁方式。一旦使用 <strong>import</strong> 语句，在使用类时，就不必再使用全名了。</p>
<p>​        可以使用 import 语句导入一个特定的类或者整个包，import 语句应该位于源文件的顶部( 但位于 package 语句的后面 )。例如，可以使用下面的这条语句来导入 java.util 包中的所有类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*</span><br></pre></td></tr></table></figure>

<p>​        然后就可以使用相关的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = <span class="keyword">new</span> LocalDate.now();</span><br></pre></td></tr></table></figure>

<p>​        而无需再和之前一样加上完整的包前缀，还可以导入包中的一个特殊类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br></pre></td></tr></table></figure>

<p>​        这同样可以达到与之前一样的效果。java.time.* 的用法较为简单，对代码的规模也没有任何的负面影响。但是说实话，更加推荐明确的指出导入的类。这样的化，代码的阅读者也能更加的明确代码撰写者使用了哪些类。</p>
<p>​        但是，需要注意的是，只能使用信号( * )导入一个包，而不能使用 import java.* 或 import java.*.*  导入以java为前缀的包。</p>
<p>​        在大多数的情况下，可以只导入你需要的包，并不必过多的考虑她们。但在发生了命名冲突的时候，就要注意包了。例如， java.util 和 java.sql 包都存在 Date 类。如果在程序中导入了这两个包，那么在编译时就会出现一个编译错误。</p>
<p>​        此时，编译器无法确认你希望使用哪个包中的 Date 类。可以增加一个特定的 import 语句来解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure>

<p>​        如果这两个 Date 类都需要使用，那么就要采用其他的方法来完成调用。即，在每个类名的前面加上完整的包名。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deadLine = <span class="keyword">new</span> java.util.Date();</span><br><span class="line"><span class="keyword">var</span> taday = <span class="keyword">new</span> java.sql.Date(...);</span><br></pre></td></tr></table></figure>

<p>​        在包中定位类是编译器的工作。类文件中的字节码总是使用完整的包名来引用其他类。</p>
<p>​    </p>
<h4 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h4><p>​        有一种 import 语句允许导入静态方法和静态字段，而不只是类。</p>
<p>​        例如，在如果在源文件顶部，加入一条指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br></pre></td></tr></table></figure>

<p>​        就可以使用 System 类中的 静态方法 和 静态字段，而不必使用类名前缀，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.println( <span class="string">&quot;Test&quot;</span> ); <span class="comment">// 等价于 System.out.println( &quot;Test&quot; );</span></span><br></pre></td></tr></table></figure>

<p>​        另外，静态导入也可以导入特定的方法或者字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out</span><br></pre></td></tr></table></figure>

<p>​        使用这种方法就可以直接导入特定的 方法 或者 字段。</p>
<h4 id="在包中增加类"><a href="#在包中增加类" class="headerlink" title="在包中增加类"></a>在包中增加类</h4><p>​        要希望将类放入包中，就必须将包的名字放在源文件的开头。即放在定义这个包中各个类的代码之前。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.horstmann.corejava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        如果没有在源文件中放置 package 语句，这个源文件中的类就属于 <strong>无名包( unnamed package )</strong> 。无名包没有包名。 到目前为止，我们定义的所有类都在这个无名包中。</p>
<p>​        将源文件放到与完整包名匹配的子目录中。例如，com.horstmann.corejava 包中的所有源文件应该防止在子目录 com \ horstmann \ corejava 中。同理，编译器将类文件也放在相同的目录结构中。</p>
<h4 id="包访问"><a href="#包访问" class="headerlink" title="包访问"></a>包访问</h4><p>​        前面已经接触访问修饰符 public 和 private。 标记为 public 的部分可以由任意类使用； 而标记为 private 的部分只能由定义她的类使用。</p>
<p>​        如果没有指定 public 或者 private ，那么这个部分默认为 public ，可以被所有的包和类访问。</p>
<p>​        在默认的情况下，包不是封闭的实体。也就是说，任何人都可以向包中添加更多的类。</p>
<h4 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h4><p>​        通过前面的知识，类储存在文件系统的子目录中，类的路径必须与包名匹配。</p>
<p>​        另外，类文件也可以储存在 JAR( Java归档 ) 文件中。在一个 JAR 文件中，可以包含多个压缩形式的类文件和子目录，这样既可以节省空间又可以改善性能。</p>
<p>​        </p>
<p>​        为了使类可以被多个程序共享，需要做到以下几点：</p>
<ul>
<li>把类文件放入到一个目录中</li>
<li>将 JAR 文件放在一个目录中</li>
<li>设置类路径，类路径时所有包含类文件的路径的集合</li>
</ul>
<p>​        由于总是会搜索 Java API 的类，所以不必显示地包含在类路径中。另外，类的路径所列出的目录和归档文件时搜寻类的 起始点 。</p>
<p>​        编译器查找文件的步骤要比虚拟机复杂不少。如果引用一个类，但没有指定其所在的包。</p>
<p>​        那么编译器就会将代码上方法所导入( import )的所有的包都检查一遍，提一嘴，这个查找过程并不会中途停止，编译器检查 import 指令，来确认是否有包含目标导入类的包。并且，如果编译器在这个检查过程中检查到两个或两个以上的目标导入类( 同名 ),编译器就会立刻报错。</p>
<p>​        另外，由于完全限定类名必须是唯一的，因此 import 指令的次序并不重要。</p>
<p>​    </p>
<h2 id="JAR文件"><a href="#JAR文件" class="headerlink" title="JAR文件"></a>JAR文件</h2><p>​        在将应用程序打包时，最好只想用户提供一个单独的文件，而不是一个臃肿的包 或者 一个包含大量类文件的目录结构。因此 JAR 文件就此诞生。由于 JAR 文件不止可以类文件，也可也包含图片，声音文件，因此 JAR 文件是压缩文件，采用的是我们熟悉的 Zip 压缩格式。</p>
<h4 id="创建-JAR-文件"><a href="#创建-JAR-文件" class="headerlink" title="创建 JAR 文件"></a>创建 JAR 文件</h4><p>​        可以使用 JDK 自己自带的工具来创建 JAR 文件，一般而言，默认在 JDK 的 bin 目录下。创建一个新的 JAR 文件最常用的命令可以使用下面的语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvf jarFileName file1 file2 .....</span><br></pre></td></tr></table></figure>

<p>​        可以将应用程序和代码库打包在 JAR 文件中。</p>
<h4 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h4><p>​        除了类文件、图像和其他资源外，每个 JAR 文件还包括一个 清单文件 ，用于描述归档文件的特殊性质。</p>
<p>​        清单文件命名为 MANIFEST.MF ， 她位于 JAR 文件的一个特殊的 META.INF 子目录中。</p>
<p>​        符合标准的最小 清单文件 极其简单： <em>Manifest-Version : 1.0</em></p>
<p>​        复杂的清单文件可以包含更多条目。这些 清单条目 被条目分成多个 <strong>节</strong> 。第一节被称之为 <strong>主节</strong> 。她作用于整个 JAR 文件，随后的条目用来指定命名实体的属性。他们都必须以一个 Name 条目开始。节和节之间用空行分开。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Manifet-Version:<span class="number">1.0</span></span><br><span class="line">lines describing <span class="keyword">this</span> archive</span><br><span class="line"></span><br><span class="line">Name : Woozle.class</span><br><span class="line">lines describing <span class="keyword">this</span> file</span><br><span class="line">Name : com/mycompany/mypkg/</span><br><span class="line">lines describing <span class="keyword">this</span> <span class="keyword">package</span></span><br></pre></td></tr></table></figure>



<h4 id="可执行-JAR-文件"><a href="#可执行-JAR-文件" class="headerlink" title="可执行 JAR 文件"></a>可执行 JAR 文件</h4><p>​        可以使用 jar 命令中的 e 选项指定程序的 入口 点，即通常需要在调用 Java 程序启动时指定的类。</p>
<p>​        不论使用哪一种方法，用户可以简单的通过下面的命令来启动程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar MyProgarm.jar</span><br></pre></td></tr></table></figure>



<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>​        JDK 包含了一个相当有用的工具  <em>Javadoc</em> ，她可以用源文件为基底生成一个 HTML 文档。实际上，Java 所用的 API 文档就是使用    <em>Javadoc</em>  这个工具生成的。</p>
<p>​        如果在源代码中添加 /** 开始的注释，可以十分容易的生成一个看起来十分专业的文档。这是一个很好的方法，因为这样可将代码和注释放在一个地方。</p>
<p>​        使用了上面方法后，由于文档注释和源代码在同一个地方，如在以后修改源代码，重新运行  <em>Javadoc</em>  就可以轻而易举的保持两者的一致性。</p>
<h4 id="注释插入"><a href="#注释插入" class="headerlink" title="注释插入"></a>注释插入</h4><p>​        Javadoc 实用工具从下面几项中抽取信息：</p>
<ul>
<li>模块</li>
<li>包</li>
<li>公共类与接口</li>
<li>公共的和受保护的构造器以及方法</li>
</ul>
<p>​        可以 ( 而言应该 ) 为每个特性编写注释，注释位置位于所描述特性的最上方，以 /** 开始，以 <em>/ 结束。 每个 /</em>* <em>/ 文档注释包含标记以及之后紧跟的  <strong>自由格式文本</strong></em>  。标记以 @ 开始，如 @since 或 @param 。</p>
<p>​        ![ 注释插入 ](./学习笔记 - 面向对象/注释抽取.JPG)</p>
<p>​        <em><strong>自由格式文本</strong></em> 的第一句应该是一句 <strong>概要性</strong> 的句子， <em>Javadoc</em> 工具会自动地将这些句子抽取出来生成概要页。</p>
<p>​        另外， 在 <em><strong>自由格式文本</strong></em>  中是可以使用 HTML 修饰符的，比如用于强调的 &lt; em &gt;…&lt; /em &gt; 而且不需要字符转义。</p>
<h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><p>​        类注释必须放在 import 语句之前，类的具体定义之后，就上上方的图，就是一个典型的类注释。</p>
<p>​        另外，在类注释中，就算不是用 * 号也是合法的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> The &#123;<span class="doctag">@code</span> System&#125; class contains several useful class fields</span></span><br><span class="line"><span class="comment"> and methods. It cannot be instantiated</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> Among the facilites provided by the &#123;<span class="doctag">@code</span> System&#125; class</span></span><br><span class="line"><span class="comment"> .........</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>​        以上的类注释方法就是合法的，不过大多数自动生成的 JDK 都会自带 * 号，而且大多 IDE 中书写类注释时会自动带上 * 号。</p>
<h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>​        每一个方法必须放在所描述的方法之前，除了通用的标记外，还可以使用下面的标记：</p>
<ul>
<li><p>@param <em>variable description</em></p>
<p>​        这个标记将给当前方法的 “ paraments ” ( 参数 ) 部分添加一个条目。这个描述可以占据多行，并且这个标记可以使用 HTML 标记。一个方法中的所有 @param 标记全部放在一起。</p>
</li>
<li><p>@return description</p>
<p>​        这个标记将给当前方法添加 “ returns ” ( 返回 ) 部分。这个描述可以跨越多行，并且可以使用 HTML 标记。</p>
</li>
</ul>
<ul>
<li><p>@throws class description</p>
<p>​        这个标记将添加一个注释，表示这个方法可能会抛出异常。有关异常的详细内容将在后面描述。</p>
</li>
</ul>
<p>​        下面给一个方法注释的例子：</p>
<p>![ 方法注释 ](./学习笔记 - 面向对象/方法注释.JPG)</p>
<h4 id="字段注释"><a href="#字段注释" class="headerlink" title="字段注释"></a>字段注释</h4><p>​        只需要对公共字段 ( 通常指的时静态常量 ) 建立文档。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*	The &quot;Hearts&quot; card suit</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Hearts = <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h4><p>​        标记 <em>@since text</em> 会建立一个 “ since ” ( 始于 ) 条目。text 可以是引入这个特性的版本的任何描述。例如，@since 1.7.1 ，另外下面的标记可以用在类文档的注释中。</p>
<ul>
<li><p>@author <em>name</em></p>
<p>​    这个标记将产生一个 “ author ” ( 作者 ) 条目，可以使用多个 @author 标记，每个 @author 标记对应一个作者。并不是非得使用这个标记，不过使用这个标记可以更好的作者。</p>
</li>
</ul>
<ul>
<li><p>@version <em>text</em></p>
<p>​    这个标记将产生一个 “ version ” ( 版本 ) 条目。这里的文本是可以对当前版本的任何描述。</p>
</li>
</ul>
<ul>
<li><p>@see &lt;  &gt;</p>
<p>​    这个标记可以生产一个链接到 &lt; &gt; 中的地址的超链接。可以为一个特性添加多个 @see 标记，但必须将她们放在一起，就如同 方法注释 的 @param 标记相同。</p>
</li>
</ul>
<h4 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a>包注释</h4><p>​        可以直接将 类、方法和变量 的注释放置在 Java 源文件中，只要用 /** … */ 文档注释就可以了。但是，想要生成 包注释 就需要每一个包目录中添加一个单独的文件。可以有如下两个方法：</p>
<ol>
<li>提供一个名为 package-info.java 的 Java 文件，这个文件必须包含一个初始的以 /** 和 */ 界定的 <em>Javadoc</em> 注释，后面是一个 package 语句。她不能包含更多的代码或注释。</li>
<li>提供一个名为 package.html 的 HTML 文件。会抽取标记 &lt; body &gt; … &lt; / body &gt; 之间的所有文本。</li>
</ol>
<h4 id="注释抽取"><a href="#注释抽取" class="headerlink" title="注释抽取"></a>注释抽取</h4><p>​        在这里，假设你希望 HTML 文件将放在名在 docDirectory 的目录下，需要执行下面的步骤：</p>
<ol>
<li><p>切换到包含想生成文档的源文件的目录。如果有嵌套的包要生成文件，就必须切换到包含子目录 com 的目录。</p>
</li>
<li><p>如果是一个包，需要运行命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -d docDirectory nameOfPackage</span><br></pre></td></tr></table></figure>



<p>​    最后，可以使用很多命名行选项对 <em>Javadoc</em> 程序进行优化。</p>
<p>​    比如可以使用 -author 和 -version 之类的命令来在文档中包含 @author 和 @version 标记。</p>
</li>
</ol>
<h2 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h2><ul>
<li>一定要保证数据的私有性<ul>
<li>这是最重要的一点，绝对不要破坏程序的封装性。当数据保持私有时，表示形式的变化不会对类的使用者产生影响，而且也更容易检测 Bug 。</li>
</ul>
</li>
</ul>
<ul>
<li>一定要对数据进行初始化<ul>
<li>Java 不会为你进行 局部变量 的初始化，但是会对对象的 实例字段 和 引用对象 进行初始化。最好不要依赖于系统的默认值，这样相当容易出现 Bug 。因此，我们应该为她们显示的提供初始值，尽量让这些问题掌握在书写者的手中。</li>
</ul>
</li>
</ul>
<ul>
<li><p>不要再类中使用过多的基本类型</p>
<ul>
<li><p>这个想法是要用其他的类来替换多个相关的基本类型，这样会使得类更加容易理解，也更容易修改。例如，用一个名为 Address 的新类来替换一个 Customer 类中以下的实例字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String street;</span><br><span class="line"><span class="keyword">private</span> String city;</span><br><span class="line"><span class="keyword">private</span> String state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> zip;</span><br></pre></td></tr></table></figure>

<p>这样一来，可以很容易地处理地址的变化。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>不是所有的字段都需要单独的字段访问器和字段更改器<ul>
<li>这个很好理解，在你的类中并不是所有的 字段 都需要被外部访问，或者被外部修改。比如类中的一些的 private 私密的字段。</li>
</ul>
</li>
</ul>
<ul>
<li>分解有过多职责的类<ul>
<li>如果一个复杂的类可以被分为两个简单的类，那么就应该把她们分解为两个简单的类。当一个类过于复杂时，其担任的功能就可能过多，导致代码的维护和检测难以进行。</li>
<li>原则上，设计类时应该和设计方法相同，尽可能的达到一个类只完成一个指定的任务。</li>
</ul>
</li>
</ul>
<ul>
<li>类名和方法名要能够体现她们的作用和职责<ul>
<li>与变量的设计相同，类应该和变量一样有一个反应自己功能的名字，这样也便于维护和检查代码。( 在标准库类中，也有一些模糊不清的类，比如 Date 类其实是一个用来处理时间的类 ) 。</li>
</ul>
</li>
</ul>
<ul>
<li>优先使用不可变的类<ul>
<li>LocalDate 类以及 java.time 包中的其他类就是不可变的 — 没有方法可以修改对象的状态。更改对象的问题在于，如果多个线程试图同时处理更新一个对象，此时就可能发生一些 <strong>神奇而不可预料</strong> 的问题。如果类是不可变的，那么就可以安全的使得多个线程共享这个对象。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="神秘的世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">学习笔记——基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-09 21:35:30" itemprop="dateCreated datePublished" datetime="2021-07-09T21:35:30+08:00">2021-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-10 23:30:26" itemprop="dateModified" datetime="2021-09-10T23:30:26+08:00">2021-09-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>基础大致有 数据类型 运算符 字符串 输入和输出 控制流程 大数 数组 7个部分</p>
<p>参考 Java核心技术卷一的第三章</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>​    和其他的语言体系相似，整型int，浮点型float 和 double，字符型 char，布尔型 boolean</p>
<h4 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h4><p>​    Java支持四种整型 int , short , long , byte  在这中 int 型最常用</p>
<p>​    其中长整型long在使用时需要一个后缀 L 或 l （ 如400000l ）</p>
<p>​    自从Java7开始，整形允许加上下划线 如 1_000_000 表示 1000000 编译器会自动去除其中的下划线，这么做方便阅读</p>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>​    Java支持两种浮点型 float 和 double 其中一般默认的都是double ，其中使用float时，会在数据的末尾加上后缀 F 或 f，实际上，很少需要单精度float的数据</p>
<p>​    浮点数中存在三个特殊浮点数值，遵顼IEEE 754 标准，具体而言为：</p>
<ol>
<li>正无穷大</li>
<li>负无穷大</li>
<li>NaN（这不是一个数字）</li>
</ol>
<p>​    例如，一个正整数除以0的结果就为无穷大 ； 计算0 / 0 或者负数的平方根结果为 NaN</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double.POSITIVE_INFINTY <span class="comment">//正无穷大</span></span><br><span class="line">Double.NEGATIVE_INFINTY <span class="comment">//负无穷大</span></span><br><span class="line">Double.NaN <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>​        Java中的字符型指char型，char型变量与Unicode编码机制有关，在Java中，char类型描述了UTF-16编码的一个代码单元</p>
<p>​        更多时候，会使用字符串String类型 而不是 char型 ，并且也并不推荐在程序中使用 char型</p>
<p>​        另外，String类型并不是基本类型</p>
<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p>​    和其他语言体系相同，Java也使用变量来储存值</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>​    声明是一条完整的Java语句，需要用分号 进行结束，在Java中，直接声明变量时，可以使用特殊字符，如 Π  但是 ‘ + ’  之类的符号不可以出现在变量名中，空格也不行</p>
<p>​    Java变量名大小写敏感且长度基本不受限制，前提是不嫌麻烦</p>
<p>​    另外，不能使用Java保留字作为变量名</p>
<h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><p>​    在声明变量后，必须使用赋值语句对变量进行<strong>显示初始化</strong>，千万不要使用未初始化的变量，Java编译器认为这种语句是错误的</p>
<p>​    在Java中，变量的初始化尽可能的靠近第一次使用的地方，这是一种良好的习惯</p>
<p>​    自从Java10开始，对于局部变量，如果可以从变量的初始值推断出它的类型，就不再需要声明变量，只需使用var关键字，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vacationDays = <span class="number">12</span>; <span class="comment">//vacationDays is an int</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">&quot;Hello&quot;</span>; <span class="comment">//greeting is a String</span></span><br></pre></td></tr></table></figure>

<p>​    另外，在Java中，并不区分变量的声明和定义</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>​    在Java中，利用关键字final指示常量，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> A = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>​    加上了关键字final的变量视为常量，常量只能被赋值一次，一旦赋值就不能再赋值了，习惯上，常量名使用全大写</p>
<h5 id="类常量"><a href="#类常量" class="headerlink" title="类常量"></a>类常量</h5><p>​    在Java中，经常希望某个常量可以被多个类使用，这种就是类常量，类常量需要使用static关键字，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> CW = <span class="number">2.54</span></span><br></pre></td></tr></table></figure>

<p>​    类常量的定义一般位于main方法的外部</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>​    运算符用于连接值。Java提供了一组丰富的算术和逻辑运算符以及数学函数</p>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>​    在Java中，使用 + - * / 表示 加 减 乘 除 四种运算，用 % 表示整数的取模操作</p>
<p>​    需要注意，整数被 0 除 会产生一个异常，而浮点数被0除则会得到无穷大 或 NaN 结果</p>
<h4 id="数学函数和常量"><a href="#数学函数和常量" class="headerlink" title="数学函数和常量"></a>数学函数和常量</h4><p>​    在Math类中，包含各种各样的数学函数，比如sqrt方法 和 pow方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(<span class="number">4</span>) <span class="comment">// 解4的平方根</span></span><br><span class="line">Math.pow(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">// 求 2 的 2</span></span><br></pre></td></tr></table></figure>

<p>​    Java的Math方法还是提供一些常用的三角函数，指数函数以及它的反函数，以及两个用于表示 pai 和 e 常量的近似值</p>
<table>
<thead>
<tr>
<th>Math.sin</th>
<th>Math.cos</th>
<th>Math.tan</th>
<th>Math.atan</th>
</tr>
</thead>
<tbody><tr>
<td>Math.atan2</td>
<td>Math.exp</td>
<td>Math.log</td>
<td>Math.log10</td>
</tr>
<tr>
<td>Math.PI</td>
<td>Math.E</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="数值类型之间的转换"><a href="#数值类型之间的转换" class="headerlink" title="数值类型之间的转换"></a>数值类型之间的转换</h4><p>​    我们经常需要将一种数值转化为另一种数值类型，下图是合法的类型转换</p>
<p>![1625969569811](C:\Users\Arsh\Blog\source_posts\学习笔记 - 基础语法\1625969569811.jpg)</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>​    在必要的时候，我们需要将double转换为int，代价是丢失一些信息，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">9.997</span>;</span><br><span class="line"><span class="keyword">int</span> nx = (<span class="keyword">int</span>)x; <span class="comment">//nx的值为9</span></span><br></pre></td></tr></table></figure>

<p>​    强制类型转换通过截断小数部分来将其转换为整形</p>
<h4 id="结合赋值和运算符"><a href="#结合赋值和运算符" class="headerlink" title="结合赋值和运算符"></a>结合赋值和运算符</h4><p>​    可在赋值中使用二元运算符，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x += <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>​    这等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>​    如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制转换</p>
<h4 id="自增和自减运算符"><a href="#自增和自减运算符" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h4><p>​    Java中借鉴了C++和C的做法，提供了自减和自增运算符，这些运算符应该搭配变量使用</p>
<p>​    在操作上，自增和自减运算符可以添加在前缀或者后缀上，前缀和后缀形式都会使得变量值变化，但在用在表达式中时，二者有区别</p>
<p>​    前缀形式会先完成加1 或 后1操作，后缀会先使用变量原来的值</p>
<p>​    建议不要再表达式中使用++ 或 – 会导致难以阅读 并且 会出现烦人的bug</p>
<h4 id="关系和boolean运算符"><a href="#关系和boolean运算符" class="headerlink" title="关系和boolean运算符"></a>关系和boolean运算符</h4><p>​    Java包含丰富的关系运算符，比如 == 和 ！=</p>
<p>​    Java延续了C++的做法，使用&amp;&amp;，||表示 与和或</p>
<p>​    最后Java支持 三元运算符 ？以下方的表达式为例</p>
<p>​    condition ? expression1 : expression2 如果condition的值为true 则执行expression1 ，否则执行expression2</p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>​    处理整形类型时，可以直接对组成整数的各个位完成操作，位运算符包括 &amp;(and) |(or)  ^(xor)  ~(not)</p>
<h4 id="括号和运算符级别"><a href="#括号和运算符级别" class="headerlink" title="括号和运算符级别"></a>括号和运算符级别</h4><p>​    对于表达式，如果不使用圆括号，就按照给出的运算符优先级次序进行计算，同一级别从左往右进行计算</p>
<p><img src="/2021/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20-%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/腾讯QQ\QQ文件\MobileFile\1625973220150.jpg" alt="1625973220150"></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>​    Java没有内置的字符串类型，而是在标准Java库中提供了一个预定义类，很自然的叫做String，每个双括号括起来的字符串都是String类的一个实例</p>
<h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p>​    String类的substring方法可以从一个较大的字符串提取出一个子串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s = greeting.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>​    对于substring函数而言，第一个参数为子串的第一个字符的位置，第二个参数为不想复制的第一个位置</p>
<p>​    在上方的例子中，子串的长度为3</p>
<h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>​    与绝大多数的设计语言一样，Java允许使用 + 号进行连接（拼接）两个字符串</p>
<p>​    当一个字符串和一个非字符串的值进行拼接时，后者会被转化为字符串</p>
<p>​    在Java11中，还提供了一个repeat方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String repeated = <span class="string">&quot;Java&quot;</span>.repeat(<span class="number">3</span>); <span class="comment">// repeated -&gt; &quot;JavaJavaJava&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h4><p>​    String类没有提供修改字符串中某个字符的方法！</p>
<p>​    你不能修改String类字符串中的某个或多个字符，在Java文档中String类对象称为不可变的</p>
<p>​    相对的，Java的字符串允许共享 即 编译器可以让字符串共享</p>
<p>​    另外，如果复制一个字符串变量，原始字符串和复制的字符串共享相同的字符，同生共死</p>
<h4 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h4><p>​    可以使用equals方法检测两个字符串是否相等，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.equals(t)</span><br></pre></td></tr></table></figure>

<p>​    对于上方的例子，若s和t相等 则返回true 否则返回 false</p>
<p>​    一定不要使用 == 来检测两个字符串是否相等，这只能确认两个字符串是否在同一个位置上，这还会产生一些讨厌的Bug</p>
<h4 id="空串和Null串"><a href="#空串和Null串" class="headerlink" title="空串和Null串"></a>空串和Null串</h4><p>​    空串“”是长度为0的字符串，可以调用以下代码检测一个字符串是否为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(str.length() == 0)</span><br></pre></td></tr></table></figure>

<p>​    当str是空串时会返回true 否则 返回false</p>
<p>​    Null串 和 空串 是不同的，这以后再说</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h4 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h4><p>​    Java中的读取输入可以使用Scanner来实现    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>​    构造完成后，可以通过Scanner的各种函数获得对应的输入，比如nextInt，nextDouble</p>
<h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>​    除了使用System.out.print（）来输出到控制台外，Java还提供了Format类</p>
<h5 id="Format类概述"><a href="#Format类概述" class="headerlink" title="Format类概述"></a>Format类概述</h5><p>​    <em>Format</em> 是一个用于格式化语言环境敏感的信息（如日期、消息和数字）的抽象基类。</p>
<p>​    <em>Java</em> 平台为格式化日期、消息和数字分别提供了三个特殊的<em>Format</em> 的子类：<em>DateFormat</em>、<em>MessageFormat</em> 和 <em>NumberFormat</em>。</p>
<h5 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h5><p>​    <em>DateFormat</em> 是<em>Format</em>类的抽象子类*,* 有一些<em>static</em>的*getXxxxInstance()*方法来获得实例。通过设置结果的长度和地区，来获得日期，时间等的格式。</p>
<p>​    <em>DateFormat</em>不太常用。一般会使用<em>SimpleDateFormat</em>子类，*newSimpleDateFormat(“yyyy-MM-dd”)<em>或</em>newSimpleDateFormat(“yyyy-MM-dd HH:mm:ss”)*等，来获得常用的时间格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">String s;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Date类的格式: Sat Aug 30 13:05:56 CST 2014 */</span></span><br><span class="line"></span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line"><span class="comment">/** 输出格式: 2014-8-30 */</span></span><br><span class="line"></span><br><span class="line">s = DateFormat.getDateInstance().format(d);</span><br><span class="line"></span><br><span class="line">System.out.println(s);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 输出格式: 2014-8-30 */</span></span><br><span class="line"></span><br><span class="line">s = DateFormat.getDateInstance(DateFormat.DEFAULT).format(d);</span><br><span class="line"></span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出格式: 2014年8月30日 星期六 */</span></span><br><span class="line"></span><br><span class="line">s = DateFormat.getDateInstance(DateFormat.FULL).format(d);</span><br><span class="line"></span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出格式: 2014-8-30 */</span></span><br><span class="line"></span><br><span class="line">s = DateFormat.getDateInstance(DateFormat.MEDIUM).format(d);</span><br><span class="line"></span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出格式: 14-8-30 */</span></span><br><span class="line"></span><br><span class="line">s = DateFormat.getDateInstance(DateFormat.SHORT).format(d);</span><br><span class="line"></span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出格式: 2014-08-30 01:02:02 */</span></span><br><span class="line"></span><br><span class="line">DateFormat format1 = <span class="keyword">new</span> SimpleDateFormat(</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">s = format1.format(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">System.out.println(s);  </span><br></pre></td></tr></table></figure>

<h5 id="NumberFormat类"><a href="#NumberFormat类" class="headerlink" title="NumberFormat类"></a>NumberFormat类</h5><ul>
<li>NumberFormat* 是所有数值格式的抽象基类。此类提供格式化和解析数值的接口。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">double num=868326.81472676;</span><br><span class="line"></span><br><span class="line"> double test=3.1415926;</span><br><span class="line"></span><br><span class="line"> //返回当前缺省语言环境的缺省数值格式。/*输出结果：868,326.815*/</span><br><span class="line"></span><br><span class="line"> String myString = NumberFormat.getInstance().format(num);</span><br><span class="line"></span><br><span class="line"> System.out.println(myString);</span><br><span class="line"></span><br><span class="line"> //getCurrencyInstance()返回当前缺省语言环境的通用货币格式/*输出结果：￥868,326.81*/</span><br><span class="line"></span><br><span class="line"> myString = NumberFormat.getCurrencyInstance().format(num);</span><br><span class="line"></span><br><span class="line"> System.out.println(myString);</span><br><span class="line"></span><br><span class="line"> //getNumberInstance() 返回当前缺省语言环境的通用数值格式/*输出结果：868,326.815*/。</span><br><span class="line"></span><br><span class="line"> myString = NumberFormat.getNumberInstance().format(num);</span><br><span class="line"></span><br><span class="line"> System.out.println(myString);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> //getPercentInstance()  返回当前缺省语言环境的百分比格式。/*输出结果：314%*/</span><br><span class="line"></span><br><span class="line">  myString = NumberFormat.getPercentInstance().format(test);</span><br><span class="line"></span><br><span class="line">  System.out.println(myString);  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  NumberFormat format = NumberFormat.getInstance();</span><br><span class="line"></span><br><span class="line">  // 设置数值的小数部分允许的最大位数。 /*输出结果：868,326.815 */</span><br><span class="line"></span><br><span class="line">  format.setMaximumFractionDigits( 3 );</span><br><span class="line"></span><br><span class="line">  System.out.println(format.format(num));</span><br><span class="line"></span><br><span class="line">  // 设置数值的整数部分允许的最大位数。 /*输出结果：26.815 */</span><br><span class="line"></span><br><span class="line">  format.setMaximumIntegerDigits(2);</span><br><span class="line"></span><br><span class="line">  System.out.println(format.format(num));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  // 设置数值的小数部分允许的最小位数。 /*输出结果：26.815 */</span><br><span class="line"></span><br><span class="line">  format.setMinimumFractionDigits(2);</span><br><span class="line"></span><br><span class="line">  System.out.println(format.format(num));</span><br><span class="line"></span><br><span class="line">  // 设置数值的整数部分允许的最小位数。 /*输出结果：26.815 */</span><br><span class="line"></span><br><span class="line">  format.setMinimumIntegerDigits(2);</span><br><span class="line"></span><br><span class="line">  System.out.println(format.format(num));</span><br></pre></td></tr></table></figure>

<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><p>​    块 是指若干条Java语句组成的语句，并用一对大括号括起来，一个块可以嵌套在另一个块中，但是不能在嵌套的两个块的声明同名的变量</p>
<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><p>​    当基本的整数和浮点数满足不了要求时，可以使用 java.math 包中的两个很有用的类 BigInteger 和 BigDecimal 这两个类可以处理任何任意长度数字序列的数值。BigInteger  对应 整形 ，BigDecimal 对应 浮点型</p>
<p>另外还有一些常量 BigInteger.ZERO , BigInteger.ONE 和 BigInteger.TEN</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>​    数组存储相同类型值的序列</p>
<h4 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h4><p>​    数组时一种数据结果，用来存储同一类型值的集合，通过一个整形下标可以访问数组中的每一个值</p>
<p>​    声明数组变量时，需要指出数组类型和数组变量的名字，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] AssHoo = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>​    一旦创建了数组，就不能在更改大小，如若需要实现动态大小，可以使用其他的数据结构 数组列表arrayList</p>
<h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><p>​    强化for循环，for-each循环是Java相比C语言中的for循环拓展而来的一种新的遍历数组的循环方式，其相对于一般的for循环更方便，而且更易查找数组内的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( 变量类型  变量名 : 数组名 ) &#123;</span><br><span class="line">    需要执行的循环语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-haruto"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>

<!--动态线条背景-->
<script type="text/javascript"
color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
